query sentence: branch-and-bound technique for algorithms
---------------------------------------------------------------------
title: 2126-very-loopy-belief-propagation-for-unwrapping-phase-images.pdf

loopi belief propag unwrap phase imag brendan freyl ralf koetter2 nemanja petrov probabilist statist infer group univers toronto http //www.psi.toronto.edu electr comput engin univers illinoi urbana abstract sinc discoveri best error-correct decod algorithm view belief propag cycle-bound graph research tri determin circumst loopi belief propag effect probabilist infer despit sever theoret advanc understand loopi belief propag knowledg problem solv use loopi belief propag error-correct decod gaussian channel propos new represent two-dimension phase unwrap problem show loopi belief propag produc result superior exist techniqu import result sinc mani imag techniqu includ magnet reson imag interferometr synthet apertur radar produc phase-wrap imag interest graph use larg number veri short cycl support evid larg minimum cycl length need excel result use belief propag introduct phase unwrap easili state fundament problem imag process ghiglia pritt real-valu observ 2-dimension grid measur modulus known wavelength take without loss general ib show wrap i-dimension waveform obtain origin waveform shown la everi time origin waveform goe wrap respect goal phase unwrap infer origin unwrap curv wrap measur use use knowledg signal probabl priori two dimens exact phase unwrap exponenti difficult 1dimension phase unwrap shown np-hard general chen zebker lc show wrap output magnet reson imag devic courtesi liang notic fring line boundari across wrap occur id show wrap terrain height measur interferometr synthet apertur radar courtesi sandia nation laboratori new mexico figur waveform measur 1-dimension grid phase-wrap version ofth waveform wavelength wrap intens magnet reson imag devic measur 2-dimension grid courtesi liang wrap topograph map measur 2-dimension grid courtesi sandia nation laboratori new mexico sensibl goal phase unwrap infer gradient field origin surfac surfac reconstruct integr equival goal infer number relat wrap integ shift everi pair neighbor measur posit shift correspond increas number wrap direct coordin wherea negat shift correspond decreas number wrap direct coordin arbitrarili assign absolut number wrap one point absolut number wrap point determin sum shift along path connect two point account direct take step direct coordin shift subtract neighbor measur like closer togeth farther apart priori i-dimension waveform unwrap optim time linear waveform length everi pair neighbor measur shift make unwrap valu close togeth possibl chosen exampl shift would wherea shift would 2-dimension surfac imag mani possibl i-dimension path two point path examin combin sinc sum shift along everi path equal view shift state variabl cut-set two point exponenti size grid make exact infer general prior np-hard chen zebker two lead fully-autom techniqu phase unwrap least squar method branch cut techniqu ghiglia pritt techniqu perform better circumst need addit inform requir hand-tweak least squar method begin make greedi guess gradient everi pair neighbor point result vector field gradient field surfac sinc valid gradient field sum gradient around everi close loop must zero curl must exampl loop measur lead gradient around loop sum least squar method proceed project vector field onto linear subspac gradient field result integr produc surfac branch cut techniqu also begin greedi decis gradient identifi untrustworthi region imag whose gradient use integr shown result section these techniqu suboptim previous attempt use relax mean field techniqu solv problem achan frey koetter here take new approach work better motiv impress result belief propag cycle-bound graph error-correct decod wiberg loelig koetter mackay neal frey kschischang kschischang frey mceliec mackay cheng contrast work ghiglia pritt chen zebker koetter introduc new framework quantit evalu impress place belief propag much closer theoret limit lead method well-known belief propag sum-product algorithm probabl propag exact graph tree pearl discov recent produc excel result graph mani cycl impress result obtain use loopi belief propag super-resolut freeman pasztor infer layer represent scene frey howev despit sever theoret advanc understand loopi belief propag weiss freeman propos modif algorithm yedidia freeman weiss knowledg problem solv loopi belief propag error-correct decod gaussian channel conjectur although phase unwrap general np-hard exist near-optim phase unwrap algorithm gaussian process prior further believ algorithm loopi belief propag loopi belief propag phase unwrap describ goal infer number relat wrap integ shift everi pair neighbor measur denot x-direct shift x y-direct shift b x shown fig.2a sum shift around everi short loop shift b x x zero perturb path chang sum shift along path valid set shift b x imag must satisfi constraint b x x sinc measur curl refer zero-curl constraint reflect fact curl gradient field way phase unwrap formul problem infer probabl set shift subject satisfi zero-curl constraint assum given set shift unwrap surfac describ loword gaussian process joint distribut shift i wrap measur x-direct shift t5 vi i i fl fl it2 figur posit x-direct shift arrow label posit y-direct shift arrow label neighbor measur patch point mark graphic model describ zero-curl constraint black disc neighbor shift variabl white disc 3-element probabl vector relat shift neighbor variabl propag across network constraint-to-shift vector comput incom shift-to-constraint vector shiftto-constraint vector comput incom constraint-to-shift vector estim margin probabl shift given data comput combin incom constra int-to-sh ift vector express form p s ex x x=l y=l n-l y=l 2u m-l 2u y=l zero-curl constraint enforc evalu argument oand evalu otherwis assum slope surfac limit hat unknown shift take valu varianc two neighbor measur unwrap imag find hat practic estim direct wrap imag phase unwrap consist make infer 's b 's probabl model exampl margin probabl hat x-direct shift given observ wrap imag kl i ex p s s x grid sum rough term exact infer intract factor joint distribut describ graphic model shown graph white disc sit border two measur mark correspond eit x-direct shift y-direct shift black disc correspond zero-curl constraint connect shift hat constrain sum robabl propag comput messag 3-vector denot pass direct everi edg network element 3vector correspond allow valu neighbor shift hese 3-vector hought probabl distribut ion possibl valu hat shift take each element constraint-to-shift messag summar evid shift involv constraint comput averag allow configur evid shift constraint exampl ill il2 il3 3-vector enter constraint shown outgo 3-vector comput use f.t4i j k j f.tljf.t2kf.t31 normal numer stabil messag produc constraint comput similar fashion shift-to-constraint messag comput weight incom constraint-to-shift messag likelihood shift exampl ill 3-vector enter x-direct shift shown outgo 3-vector il2 comput use normal messag produc y-direct shift comput similar fashion at step message-pass process messag edg connect shift variabl combin produc approxim margin probabl shift given observ exampl ill il2 3-vector enter x-direct shift shown approxim p x il i f.tlif.t2i lf.tljf.t2j given wrap imag varianc estim direct wrap imag probabl vector initi uniform distribut probabl vector propag across graph iter fashion differ message-pass schedul possibl rang fulli parallel forwardbackward-up-down type schedul messag pass across network right left grid each iter take o n scalar comput after probabl propag converg after fix number iter estim margin probabl shift given data comput probabl valu each shift variabl select result configur shift integr obtain unwrap surfac if some zero-curl constraint remain violat robust integr techniqu least squar integr ghiglia pritt use experiment result general belief propag cycle-bound graph guarante converg even if converg approxim margin may close true margin so algorithm must verifi experi surfac drawn gaussian process prior find belief propag algorithm produc signific lower reconstruct error least squar method branch cut techniqu here focus perform algorithm real data record synthet apertur radar devic sinc algorithm assum surfac gaussian given shift valid concern perform well when gaussian process prior incorrect en co minimum wavelength requir error-fre unwrap use alg infer relat shift wavelength figur after iter belief propag use phase-wrap surfac id hard decis made shift variabl result shift integr produc unwrap surfac reconstruct error versus wrap wavelength for techniqu least squar method branch cut techniqu 3a show surfac obtain set mean squar differ neighbor wrap valu appli iter belief propag make hard decis for integ shift integr result gradient sinc real data know ground truth howev compar least squar method algorithm preserv detail branch cut techniqu abl unwrap entir surfac obtain quantit result reconstruct error use surfac produc least squar method the ground truth determin the effect wrap wavelength algorithm perform rewrap surfac use differ wavelength for each wavelength we comput the reconstruct error for belief propag least squar branch cut note use least squar obtain the ground truth we may bias result favor least squar 3b show the logarithm mean squar error in the gradient field the reconstruct surfac function the wrap wavelength on log-scal the plot for the mean squar error in surfac height look similar as unwrap becom imposs as unwrap becom trivial sinc wrap occur so algorithm waterfall-shap curv the belief propag algorithm clear obtain signific lower reconstruct error view anoth way belief propag toler much lower wrap wavelength for a given reconstruct error also turn for surfac imposs for algorithm infer relat shift obtain a reconstruct error unless a belief propag obtain a zero-error wavelength signific closer this limit the least squar method the branch cut techniqu conclus phase unwrap a fundament problem in imag process although it shown np-hard for general prior chen zebker we conjectur exist a near-optim phase unwrap algorithm for gaussian process prior further we believ algorithm to loopi belief propag our experiment result show loopi belief propag obtain signific lower reconstruct error compar to the least squar method the branch cut techniqu ghiglia pritt perform close to the theoret limit for techniqu infer relat wrap the belief propag algorithm run in the time as the techniqu
----------------------------------------------------------------

title: 4338-rapid-deformable-object-detection-using-dual-tree-branch-and-bound.pdf

rapid deform object detect use dual-tre branch-and-bound iasona kokkino center visual comput ecol central de pari iasonas.kokkino ecp.fr abstract work use branch-and-bound effici detect object deform part model instead evalu classifi score exhaust imag locat scale use bb focus promis imag locat core problem comput bound accommod part deform adapt dual tree data structur problem evalu approach use mixture-of-deform part model obtain exact result time faster averag also develop multiple-object detect variat system hypothes categori insert common prioriti queue problem find strongest categori imag result speedup introduct deform part model dpms deliv state-of-the-art object detect result challeng benchmark train discrimin becom standard object recognit research heart model lie optim merit function classifi scorewith respect part displac global object pose work take classifi grant use model focus optim problem common detect algorithm use conjunct dpms reli general distanc transform gdts whose complex linear imag size despit amaz effici algorithm still need first evalu score everywher pick maxima work use branch-and-bound conjunct part-bas model exploit dual tree data structur develop origin acceler oper relat kernel densiti estim use dts provid bound requir branch-and-bound method fair generic appli star-shap graphic model involv continu variabl pairwis potenti express separ decreas binari potenti kernel evalu techniqu use mixture-of-deform part model algorithm deliv exact result time faster also develop multiple-object detect variat system object hypothes insert prioriti queue task find best k-best object hypothes imag result speedup previous work effici detect cascad object detect led prolifer vision applic far less work exist deal part-bas model combinator match extens studi rigid object use detect object instanc categori recent work focus reduc high-dimension pose search space detect initi simplifi cost function optim most use idea similar coarse-to-fin process recent work threshold pre-comput train set use prune comput result substanti speedup compar gdts branch-and-bound priorit search promis imag area indic upper bound classifi score influenti paper effici subwindow search ess techniqu upper bound bag-of-word classifi score deliv bound requir bb later combin graph-cut bb object segment general cascad system devis effici detect nonlinear classifi work posit respect work follow unlik exist bb work use dpm cost therebi accommod part rigor energi minim framework unlik pruning-bas work make approxim assumpt legitim stop comput method exact obtain bound requir bb dual tree best knowledg dual tree minim use object detect awar work use dts effici generat particl nonparametr belief propag show dts use part-bas detect relat conceptu entir differ technic preliminari first describ cost function use dpms outlin limit gdt-base detect final present concept dual tree relev set due lack space refer detail dpms dual tree merit function dpms consid star-shap graphic model consist set node np n0 call root part node n1 np connect root node unari observ potenti indic fidel imag node inner product hog featur discrimin wp locat xp hp vp part constrain respect root locat v0 term quadrat binari potenti bp xp form bp xp xp ip xp h0 hp vp v0 vp ip diag hp vp diagon precis matrix mp nomin differ root-part locat freeli altern vector horizontal/vert h/v coordin moreov consid h0 v0 larg enough b0 xp zero xp practic infinit elsewher root merit part xp given mp xp xp bp xp sum give score mp xp root-and-part configur xp detector score point obtain maxim amount comput max mp xp max xp hp hp vp vp xp xp gdt use maxim summand joint valu time n number possibl locat dramat faster naiv o n comput p-part model complex decreas o n o n still factor make thing slow larg imag know certain threshold use detect classifi train svms gdt-base approach turn wast treat equal imag locat even quick realiz classifi score exceed threshold illustr show part-root configur give maximum score score bicycl model whole imag domain approach input detect result detector score bb arg maxx bb figur motiv branch-and-bound approach standard part-bas model evalu classifi score whole imag domain typic tini portion imag domain positivein draw black contour around svm-base classifi bb ignor larg interv low upper bound valu postpon explor favor promis one show heat map upper bound interv visit bb strongest locat explor interv visit locat explor speed up detect upper bound score detector within interv use low-cost oper allow us use priorit search strategi refin bound promis interv postpon explor less promis interv demonstr show heat map upper bound interv visit bb part imag heat map fine grain correspond imag locat seem promis goal maxim bb discard huge amount comput shown even conserv criterion find larg part imag domain effect ignor algorithm obtain refin bound around interest imag locat dual tree data structur set-set interact main technic challeng effici comput upper bound model involv deform part main contribut consist realiz accomplish dual tree data structur give high-level descript dual tree leav concret aspect adapt detect problem assum reader familiar kd-tree dual tree develop effici evalu express form k xj xs xd separ decreas kernel gaussian diagon covari refer xs sourc term xd domain term idea sourc point xs generat field want evalu domain locat xp naiv perform comput consid source-domain interact take oper dual tree algorithm effici comput sum use two kd-tree one sourc locat xs anoth domain locat xd allow substanti speedup comput domain point illustr chunk sourc point affect chunk domain point skip comput domain-sourc point interact dpm opitim use dual tree branch bound brand bound maxim algorithm non-parametr non-convex even nondifferenti function bb search interv contain function maximum use priorit search strategi prioriti interv determin function upper bound within start interv contain whole function domain bb increas narrow solut step interv solut pop prioriti queue split sub-interv branch new upper bound interv comput bound interv insert prioriti queue process repeat singleton interv pop bound tight singleton first singleton function global maximum figur left dual tree effici deal interact sourc red domain point blue use easili comput bound instanc point lie squar larg effect point squar therefor need go finer level resolut exact estim interact right illustr term involv geometr bound comput come case dpm criterion develop sec sum score form sp max mp xp max up hp vp hp h0 hp vp v0 vp xp hp vp use dual tree terminolog sourc point correspond part locat xp xsp xp domain point object locat xd dual tree allow us effici deriv bound sp xd score set object locat due set part locat onc form add part bound score sp xd provid bound need branch-and bound present approach seri intermedi problem may amen simpler solut complex solut discuss final lead algorithm maxim one domain point first introduc notat index source/domain point xs xd use i/j respect denot wip up unari potenti part locat shift unari score nomin offset give new sourc locat hi vi hi vi final drop mp hp vp unless necessari write v0 max h hi h0 vi v0 sp evalu v0 use priorit search interv sp start sp gradual narrow best priorit interv use kd-tree sourc point xsp quick comput bound specif sn set children n-th node kd-tree sp consid subproblem mn v0 max sn h hi h0 vi v0 max sn gi gi h hi h0 vi v0 stand geometr part know point hi vi within sn hi rn vi bn tn left right bottom top axe defin n bound box bn bound gi within sn follow gn min l h0 min b v0 gn max h0 h0 max v0 v0 gn gi gn sn upper bound zero insid bn use boundari bn lie closest v0 v0 outsid bn lower bound use distanc v0 furthest point within bn regard term bound use valu wj arg maxi sn clear suit upper bound lower bound sinc gi gn sn maxi sn gi wj gj wj gn wj gn provid proper lower bound maxi sn gi sum up bound wj gn mn v0 wj gn l1 l2 m1 m2 n1 n2 o1 o2 figur support prune sourc node among possibl support domain-nod upper lower bound shown number right node use prune here upper bound smaller maxim lower bound among support impli upper bound n children contribut l children shown here l1 surpass lower bound o children thus safe remov support use upper bound priorit search maximum v0 describ tabl start root kd-tree expand children node estim prioritiesupp bound insert prioriti queue search stop first leaf node pop provid maxim upper lower bound coincid element wait queue smaller upper bound lower bound use sec maxim domain point describ kd-tree provid bound singl domain point case describ dual tree speedup oper treat multipl domain point simultan specif consid follow maxim problem arg max arg max max h hi hj vi vj x xd j xd set domain points/indic sourc indic previous algorithm could deliv comput repeat xd pick maxim repeat similar check neighbor domain point instead done joint origin dual tree work build second kd-tree domain point domain tree oppos sourc tree node domain tree domain-nod correspond interv domain point process joint save repetit similar bound oper quick discard larg domain area poor bound bound oper sec consid effect sourc point contain node sn sourc tree differ bound maximum quantiti domain point contain domain-nod dl specif consid quantiti ml n max max j dl sn h hi hj vi vj bound gi j h hi hj vi vj involv two 2d interv one domain-nod one domain-nod interv node center hn vn dimens dh n dv n use h dh l dh n v dv l dv n write gl n max hn hl h hl hn h max vn vl v vl vn v gl n max hn hl h hl hn h max vn vl v vl vn d v illustr these bound upper bound zero box overlap els equal scale distanc closest point lower bound use furthest point two box sec use wn maxi sn first term bound ml n follow gl n wn ml n gl n wn express bound maxim valu point domain-nod use contribut point source-nod initi goal find maximum use possibl sourc point contribut describ recurs approach limit set sourcenod consid manner inspir multi-recurs approach associ everi domain-nod set sl support source-nod yield maxim contribut point start associ root node domain tree root node source-tre mean domain-sourc point interact origin consid recurs increas resolut domain-tre parallel resolut source-tre specif determin support child domain-nod consid children source-nod sl formal denot pa ch parent child oper respect sm n spa goal reduc comput keep sm small achiev prune base lower upper bound deriv main observ go parent children decreas number source/domain point tighten bound make upper bound less optimist lower bound optimist denot maxim lower bound contribut parent node gl maxn sl gl n mean gk gl pa k flip side gl n gk q pa k pa q this mean sourcenod parent level gl n gl children level children contribut someth wors gm lower bound l child score therefor need keep among sl children contribut certain wors best contribut node children base this observ reduc set support guarante optim pseudocod summar this algorithm provid tabl bound use priorit search algorithm maximum algorithm use prioriti queue domain tree node initi root domain tree whole rang possibl locat iter pop domain tree node queue comput upper bound support children push prioriti queue first leaf node pop contain best domain locat upper bound equal lower bound node prioriti queue smaller upper bound therefor result better solut maxim domain point multipl part branch bound dpms algorithm describ previous subsect essenti branch-and-bound algorithm maxim merit function arg max arg max max h hi h0 vi v0 sp correspond dpm single-part see this recal step bb pop domain function maxim prioriti queue split subdomain branch comput new upper bound subdomain bound our case branch amount consid two descend domain node pop bound amount take maximum upper bound domain node support single-part dpm optim problem rather trivial adapt techniqu multipart case easi this rewrit conveni form v0 max wp hp hpi h0 vp vip v0 use convent use name consid use point object part subtract mp hi vi yield simpl quadrat form sinc mp part-depend superscript hi vi general differ variabl differ part so brought back subscript these final wp depend sinc imag point give differ unari potenti differ object part this form realiz comput upper bound within rang valu requir branch-and-bound easi singl term previous secpp tion specif mp mp individu part contribut pp pp sinc maxx mp maxx mp we separ upper bound individu part contribut sum up get overal upper bound pseudocod describ maxim algorithm provid tabl note each part kdtree sourct p we build separ source-tre per part use part-specif coordin hp weight wp each part contribut score comput use support lend node total bound obtain sum individu part bound singl domain point st sourc tree locat out arg maxxi st push s st.root pop s pop popped.ub popped.lb return pop end side left right child popped.sid child.ub boundu x child child.lb boundl x child push s child end end multipl domain point multipl part dt sourc trees/domain tree out arg maxx dt maxi st xp seed dt.root seed.support p st p .root end push s seed pop s pop if popped.ub popped.lb return pop end if side left right child popped.sid ub part supp descend popped.supp part up s bound child supp dt st p child.supp part ub ub up end child.ub ub push s child end end multipl domain point st dt source/domain tree out arg maxx dt maxi st seed dt.root seed.support st.root push s seed pop s pop if popped.ub popped.lb return pop end if side left right child popped.sid supp descend popped.supp ub supc bound child supp dt st child.ub ub child.supc supc push s child end end bound routin child support dt st out supch lb chosen support max lb ub lb support ub n boundu dt.node child st.node n lb n boundl dt.node child st.node n end maxlb max lb supch support find ub maxlb return supch maxlb tabl pseudocod algorithm present section result applic deform object detect estim merit bb we first compar mixtures-of-dpm develop distribut we direct extend branch-and-bound techniqu we develop singl dpm deal multipl scale mixtur dpms insert object hypothes queue detect multipl instanc object at multipl scale we continu bb get best score object hypothesi termin criterion we choos stop we pop interv whose upper bound fix threshold our techniqu deliv essenti result one minuscul differ bb use float point arithmet part locat gdt necessarili process at integ resolut result ident we therefor provid detect perform curv time result come time effici in we compar result origin dpm mixtur model our implement we use imag pascal dataset mix model differ object clase gain vari per categori we consid standard detect scenario we want detect object in imag score certain threshold we show speedup singl object speedup imag rank speedup front end speedup m object best speedup object k best imag rank imag rank imag rank figur single-object speedup branch bound compar gdts imag from pascal dataset multi-object speedup speedup due front-end comput unari potenti pleas see text detail threshold affect speedup we obtain for conserv threshold speedup typic tenfold we becom aggress doubl second applic we consid problem identifi domin object present in imag categori give largest score typic simpler model like bag-of-word classifi appli this problem base understand part-bas model time-consum therefor appli larg set model imag would impract our claim branch-and-bound allow us pursu differ approach in fact have object categori increas speed detect if we leav unari potenti comput asid in specif our approach direct extend multiple-object detect set long score comput differ object categori commensur insert in prioriti queue in our experi we observ we get respons faster introduc model reason for this includ our object repertoir model give larg score help bb stop otherwis bb keep search for anoth object in plot we show systemat result the pascal dataset we compar the time would requir gdt perform detect all multipl object consid in pascal a model simultan explor all model in we show find the first-best result acceler the number object increas in we show increas the in k-best affect the speedup for small valu the gain becom more pronounc cours if we use a fix threshold the speedup would chang compar plot sinc essenti the object interact in way we use nonmaximum suppress but as we turn the best-first problem the speedup becom dramat rang in the order up a hundr time we note the time refer the messag pass part implement gdt the comput unari potenti common for model current the bottleneck even though tangenti our contribut in this paper we mention as shown in plot we comput unari potenti approxim five time faster the single-thread convolut provid exploit matlab s optim matrix multipl routin conclus in this work we introduc dual-tre branch-and-bound for effici part-bas detect we use dual tree to comput upper bound on the cost function a part-bas model therebi deriv a branch-and-bound algorithm for detect our algorithm exact make approxim deliv ident result the dpms use in but in typic less time further we shown the flexibl priorit search allow us to consid new task as multiple-object detect yield further speedup the main challeng for futur work to reduc the unari term comput cost we intend to use bb for this task acknowledg we grate to the author of for make their code avail and to the review for construct feedback this work fund grant anr-10-jcjc
----------------------------------------------------------------

title: 2780-spectral-bounds-for-sparse-pca-exact-and-greedy-algorithms.pdf

spectral bound spars pca exact greedi algorithm baback moghaddam merl cambridg ma usa baback merl.com yair weiss hebrew univers jerusalem israel yweiss cs.huji.ac.il shai avidan merl cambridg ma usa avidan merl.com abstract spars pca seek approxim spars eigenvector whose project captur maxim varianc data cardinality-constrain non-convex optim problem np-hard encount wide rang appli field bio-informat financ recent progress focus main continu approxim convex relax hard cardin constraint contrast consid altern discret spectral formul base variat eigenvalu bound provid effect greedi strategi well provabl optim solut use branch-and-bound search moreov exact methodolog use reveal simpl renorm step improv approxim solut obtain continu method result perform gain discret algorithm demonstr real-world benchmark data extens mont carlo evalu trial introduct pca indispens basic tool factor analysi model data despit power popular one key drawback lack spars factor load linear combin input variabl yet spars represent general desir sinc aid human understand gene express data reduc comput cost promot better general learn algorithm machin learn input spars close relat featur select automat relev determin problem endur interest learn communiti earliest attempt sparsifi pca statist literatur consist simpl axi rotat compon threshold under goal essenti subset select often base identif princip variabl first true comput techniqu call scotlass jolliff uddin provid proper optim framework use lasso prove comput impract recent zou propos eleg algorithm spca use elast net framework l1 penal regress regular pcs solv effici use least angl regress lar subsequ aspremont relax hard cardin constraint solv convex approxim use semi-definit program direct formul spars pca call dscpa yield promis result compar better zou al lasso-bas method demonstr standard pit prop benchmark dataset known statist communiti lack spars subsequ difficulti interpret pursu altern approach use spectral formul base variat principl courant-fisch min-max theorem solv maxim eigenvalu problem dimensionality-constrain subspac natur discret view lead simpl post-process renorm step improv approxim solut given also provid bound sub optim import point way toward exact provabl optim solut use branch-and-bound search exact comput strategi parallel ko solv differ optim problem maxim entropi bound determin experi demonstr power greedi exact algorithm first solv optim spars factor real-world pit prop data de facto benchmark use present summari find larg compar studi use extens mont carlo evalu lead algorithm spars pca formul spars pca cast cardinality-constrain quadrat program given maxim quadrat form symmetr positive-definit covari matrix ax varianc spars vector non-zero element card x card x denot l0 norm optim problem non-convex np-hard therefor intract assum solv optim vector subsequ spars factor obtain use recurs deflat standard numer routin spars control valu differ factor view design paramet unknown quantiti known oracl ala current guidelin set especi multipl factor orthogon often relax unlik ordinari pca decomposit may unique.1 inde one contribut paper provid sound theoret basi select thus clarifi art craft spars pca factor max subject note without cardin constraint quadrat form rayleighritz quotient obey analyt bound min ax/x0 max correspond uniqu eigenvector solut therefor optim object valu varianc simpli maximum eigenvalu princip eigenvector un note throughout paper rank ui increas order magnitud henc min max nonlinear cardin constraint howev optim object valu strict less max princip eigenvector longer instrument solut nevertheless show eigenvalu continu play key role analysi design exact algorithm optim condit first let us consid condit must true oracl reveal optim solut us unit-norm vector cardin yield maximum object valu would necessarili impli ak rk contain non-zero element ak princip submatrix obtain delet row column correspond zero indic equival extract row column non-zero indic like k-vector unit norm ak equival standard unconstrain rayleigh-ritz quotient sinc subproblem maximum varianc max ak must optim object summar import observ follow proposit note multi-factor version ill-pos without addit constraint basi orthogon cardin variabl redund ordin rank alloc varianc proposit optim valu spars pca optim problem equal max k princip submatrix largest maxim eigenvalu particular non-zero element optim spars factor exact equal element u k princip eigenvector k underscor inher combinatori natur spars pca equival class cardinality-constrain optim problem howev despit provid exact formul reveal necessari condit optim simpl matrix term proposit suggest effici method actual find princip submatrix k short enum exhaust search impract due exponenti growth possibl submatric still exhaust search viabl method small guarante optim toy problem small real-world dataset thus calibr qualiti approxim via optim gap variat renorm proposit immedi suggest rather simpl turn quit effect comput fix improv candid spars pc factor obtain continu algorithm various solut found proposit let unit-norm candid factor cardin found approxim techniqu let non-zero subvector uk princip maximum eigenvector submatrix ak defin non-zero indic uk ak optim solut nevertheless replac nonzero element uk guarante increas varianc ak variat renorm suggest somewhat iron given continu approxim solut almost certain better discard load keep sparsiti pattern solv smaller unconstrain subproblem indic submatrix ak simpl procedur fix refer herein never decreas varianc sure improv continu algorithm perform particular rather expedi ad-hoc techniqu simpl threshold set smallest absolut valu load un zero normal unit-norm therefor recommend spars pca section illustr straw-man algorithm enhanc proper renorm consequ past perform benchmark use simpl techniqu may need revis previous result pit prop dataset section inde spars pca factor publish literatur readili improv almost inspect proper renorm mere cost singl k-by-k eigen-decomposit eigenvalu bound recal object valu bound spectral radius max rayleigh-ritz theorem furthermor spectrum princip submatric shown play key role defin optim solut surpris two eigenvalu spectra relat inequ known inclus principl theorem inclus principl let symmetr matrix spectrum let ak princip submatrix eigenvalu ak integ ak proof proof omit rather straightforward consequ impos sparsiti pattern cardin addit orthogon constraint variat inequ courant-fisch min-max theorem exampl word eigenvalu symmetr matrix form upper lower bound eigenvalu princip submatric special case lead well-known eigenvalu interlac properti symmetr matric henc spectra interleav interlac eigenvalu larger matrix bracket smaller one note positive-definit symmetr matric covari augment am ad new variabl alway expand spectral rang reduc min increas max thus eigenvalu maxim inequ constraint card x tight equal optimum therefor maximum varianc achiev preset upper limit cardin moreov function optim varianc given cardin monoton increas rang max max max largest diagon element varianc henc concis inform way quantifi perform algorithm plot varianc curv compar optim sinc seek maxim varianc relev inclus bound obtain set yield lower upper bound ak max ak max ak max show k-th smallest eigenvalu lower bound maximum varianc possibl cardin util lower bound away guesswork oracl set interest see spectrum tradit guid select eigenvector dimension reduct classic pca also consult spars pca help pick cardin requir captur desir minimum varianc lower bound also use speed branch-and-bound search next section note close max practic princip submatrix ak yield near-optim solut right-hand inequ fix loos upper bound max branch-and-bound search intermedi subproblem am yield new tighter bound max am object therefor bound comput effici relat inexpens use power method inclus principl also lead interest constraint nest submatric exampl among possibl princip submatric obtain delet j-th row column least one submatrix a\j whose maxim eigenvalu major fraction parent see am implic this inequ search algorithm simpli possibl spectral radius everi submatrix a\j arbitrarili small especi larg henc larg matric larg cardin near varianc captur combinatori optim given proposit inclus principl interlac properti especi monoton natur varianc curv general class binari integ program optim techniqu seem ideal suit spars pca inde greedi techniqu like backward elimin alreadi suggest bound start full index set i sequenti delet variabl yield maximum max element remain howev small cardin comput cost backward search grow near maximum complex henc counterpart forward select prefer start null index set i sequenti add variabl yield maximum max element select forward greedi search worstcas complex best overal strategi this problem empir found bi-direct greedi search run forward pass plus second independ backward pass pick better solut this prove remark effect extens mont carlo evalu realworld dataset refer this discret algorithm greedi spars pca gspca despit expedi near-optim greedi search nevertheless worthwhil invest optim solut strategi especi spars pca problem applic domain financ engin even small optim gap accru substanti loss time ko branch-and-bound reli comput effici bound case upper bound use activ subproblem fifo queue depth-first search lower bound use sort queue effici best-first search this exact algorithm refer espca guarante termin optim solut natur search time depend qualiti varianc initi candid solut found dual-pass greedi search gspca found ideal initi espca qualiti typic quit high note howev even good initi branch-and-bound search take long time hour practic earli termin set threshold base eigenvalu bound use general cost-effect strategi recommend first run gspca least forward pass either settl near-optim varianc els use initi espca find optim solut full gspca run ad benefit give near-optim solut cardin run-tim typic faster singl approxim continu method experi evalu perform gspca valid espca various synthet covari matric well real-world dataset uci ml repositori excel result present typic exampl order illustr advantag power discret algorithm particular compar perform continu techniqu simpl threshold spca use elast net l1 regress dspca use semidefinit program first revisit pit prop dataset becom a standard benchmark a classic exampl difficulti interpret fulli load factor standard pca first ordinari pcs captur total varianc follow methodolog compar explanatori power exact method espca use spars pcs tabl show first pcs load spca captur varianc a cardin pattern k pcs thus total non-zero load wherea dspca captur a sparser cardin pattern total non-zero load we aim even sparser pattern non-zero load yet captur near varianc spca load slight less dspca load use evalu protocol we compar cumul varianc cumul cardin publish result spca dspca figur goal match explain varianc a sparser represent espca load tabl optim definit given section run-tim espca includ initi a bi-direct pass gspca neglig this dataset comput factor took less msec matlab a 3ghz p4 spca pc1 pc2 pc3 dspca pc1 pc2 pc3 espca pc1 pc2 pc3 x3 x4 x5 x6 x7 x8 x9 tabl load first spars pcs pit prop data see figur plot correspond cumul varianc origin spca dspca load taken spca dspca espca spca dspca espca cumul cardin cumul varianc pcs pcs figur pit prop cumul varianc cumul cardin first spars pcs sparsiti pattern cardin ki pci spca magenta dspca green an optim espca red factor load first spars pcs shown tabl origin spca dspca result taken specif demonstr benefit variat renorm section consid spca first spars factor tabl 1st row spca block found iter penal optim unit-norm scale captur total data varianc variat renorm varianc increas similarili first spars factor dspca tabl row dspca block captur total varianc wherea variat renorm captur a gain mere addit cost a eigen-decomposit given variat renorm result maximum varianc possibl indic sparsiti pattern omit a simpl post-process step counter-product sinc otherwis approxim would a sens doubli sub-optim global local subspac subset sparsiti pattern found we give a repres summari our extens mont carlo evalu gspca continu algorithm show typic average-cas perform we present result random covari matric synthet stochast brownian process various degre smooth rang sub-gaussian supergaussian everi mc run consist covari matric normal varianc curv matrix espca use find optim solut ground truth subsequ calibr analysi perform evalu spca we use lars-bas elast net spca matlab toolbox sjo strand equival zou al spca sourc code also freeli avail in r. dspca we use author matlab sourc code use sdp toolbox sedumi1.0x main dspca routin primaldec a call instead per recommend calibr document in in our mc evalu continu method spca dspca variat renorm post-process appli declar solut note compar gspca raw output algorithm would rather pointless sinc st spca dspca gspca log frequenc varianc dspca origin dspca fix optim cardin optim ratio figur typic varianc curv a continu algorithm without post-process origin dash green variat renorm fix solid green optim varianc black espca optim ratio increas gain mont carlo studi log-likelihood optim ratio max-complex st blue dspca green spca magenta gspca red continu method fix in frequenc mean optim ratio st spca dspca gspca cardin st spca dspca gspca cardin figur mont carlo summari statist mean distribut optim ratio figur estim probabl find optim solut cardin without fix varianc curv mark diminish in figur figur show histogram optim ratio ratio captur optim varianc shown half-spars a typic mc run differ covari matric in order view one-sid tail distribut we plot log histogram valu figur show correspond mean valu optim ratio among continu algorithm sdp-base dspca general effect almost compar gspca smaller matric lars-bas spca match dspca in term complex speed howev spca time faster dspca but gspca time faster spca final we note even simpl threshold enhanc variat renorm perform quit adequ despit simplic captur at least optim varianc seen in figur figur show an altern but reveal perform summari fraction trial in optim solut actual found essenti likelihood success this all-or-noth perform measur elicit import differ the algorithm in practic term gspca capabl find the optim factor more the time for dspca natur without the variat fix shown continu algorithm rare ever found the optim solut discuss the contribut this paper summar an exact variat formul spars pca requisit eigenvalu bound a principl choic a simpl renorm fix for continu method fast effect greedi search gspca a less effici but optim method espca surpris simpl threshold the princip eigenvector shown rather effect especi given the perceiv straw-man consid natur perform vari the effect rank eigen-gap the covari matrix in fact hard show if a exact rank-1 st inde an optim strategi for howev beyond special case continu method ultim competit discret algorithm without the variat renorm fix in section we note the somewhat remark effect gspca entir unexpect support by empir observ in the combinatori optim literatur greedi search sub modular cost function the monoton properti the varianc curv known produc good result in term qualiti solut gspca consist out-perform continu algorithm runtim typic faster lars-bas spca rough faster sdp-base dspca matlab cpu time averag nevertheless we view discret algorithm as complementari tool especi sinc the lead continu algorithm distinct advantag for exampl with highdimension dataset zou al lars-bas method current the viabl option sinc it not reli comput store a huge covari matrix although aspremont mention the possibl solv larger system much faster use nesterov 1st-order method this would requir a full matrix in memori as discret algorithm still their sdp formul an eleg robust interpret also appli to non-squar matric for a spars svd acknowledg the author would like to thank karl sjo strand dtu for custom code help advic in use the lars-spca toolbox gert lanckriet berkeley for provid the pit prop data
----------------------------------------------------------------

title: 5495-learning-to-search-in-branch-and-bound-algorithms.pdf

learn search branch-and-bound algorithm he he hal daum e iii depart comput scienc univers maryland colleg park md hhe hal cs.umd.edu jason eisner depart comput scienc john hopkin univers baltimor md jason cs.jhu.edu abstract branch-and-bound wide use method combinatori optim includ mix integ program structur predict map infer work focus develop problem-specif techniqu littl known systemat design node search strategi branch-and-bound tree address key challeng learn adapt node search order class problem solvabl branch-and-bound strategi learn imit learn appli algorithm linear program base branch-and-bound solv mix integ program compar method one fastest open-sourc solver scip effici commerci solver gurobi demonstr approach achiev better solut faster four mip librari introduct branch-and-bound systemat enum method global optim nonconvex combinatori problem machin learn communiti b b use infer tool map estim appli domain appli infer stage structur predict problem depend pars scene understand ancestr sequenc reconstruct b b recurs divid feasibl set problem disjoint subset organ tree structur node repres subproblem search subset node comput bound subproblem rule possibl subset contain optim solut subset partit branch need crucial question b b specifi order node consid effect node order strategi guid search promis area tree improv chanc quick find good incumb solut use rule node unfortun theoret guarante general solut node order current known instead design node order heurist manual problem type propos speed b b search automat learn search heurist adapt famili problem non-problem-depend learn approach learn problem-specif polici appli famili problem solvabl b b framework use imit learn automat learn heurist free trial-and-error tune rule design domain expert b b algorithm dynam decision-mak decision-mak process adapt three scale first learn differ strategi differ problem type second within problem type evalu hard problem instanc base featur describ solv progress third within problem instanc adapt search strategi differ level b b tree make decis base node-specif featur materi base upon work support nation scienc foundat grant train exampl prune inf ub lb global lower upper bound ub lb node expans order ub lb optim node fathom node ub lb inf min 3x 5y 3x 5y figur use branch-and-bound solv integ linear program minim easi incorpor heurist hand-design strategi handl heurist set weight differ heurist domain knowledg manual experiment model multipl heurist simpli plug state featur polici allow hybrid heurist learn effect assum small set solv problem given train time problem solv test time type learn node select polici node prune polici solv train problem node select polici repeat pick node queue unexplor node node prune polici decid pop node worth expand formul b b search sequenti decision-mak process design simpl oracl know optim solut advanc expand node contain optim solut use imit learn learn polici mimic oracl behavior without perfect inform polici must even mimic oracl would act state oracl would reach state may encount test time appli approach linear program base b b solv mix integ linear program milp problem achiev better solut faster milp problem librari gurobi recent fast commerci solver competit cplex scip one fastest open-sourc solver branch-and-bound framework applic mix integ linear program consid optim problem minim feasibl set usual discret b b use divid sp conquer strategi recurs divid subset f1 f2 fp fi recurs tree enumer tree feasibl solut whose node subproblem edg partit condit slight abus notat use fi refer subset correspond b b node convex relax subproblem solv provid upper/low bound node descend denot upper lower bound node ub fi lb fi respect ub lb bound function common set b b ubiquit appli milp milp optim problem linear object constraint also requir specifi variabl integ assum minim object function milp node drop integr constraint solv lp relax present concret exampl figur optim problem shown lower right corner node local lower bound shown lower half circl found lp solver local upper bound shown upper part circl avail feasibl solut found node automat get upper bound lp solut happen integ feasibl may obtain heurist b b maintain queue activ node start singl root node step pop node fi use node select strategi comput bound node fi root problem solut rank node push children algorithm polici learn yes pop fathom yes queue empti yes prune no ds dp problem set ds dp ollect xampl q ds ds dp train classifi use ds dp return best dev set figur method runtim left polici learn algorithm right left policy-guid branch-and-bound search procedur round rectangl shown blue execut polici right dagger learn algorithm start use oracl polici solv problem collect exampl along oracl trajectori iter retrain polici exampl collect far train set dd ds collect addit exampl run newli learn polici ollect xampl procedur describ algorithm fathom no explor subtre one follow case true lb fi larger current global upper bound mean solut subtre possibl better incumb lb fi ub fi point b b found best solut current subtre subproblem infeas figur fathom node shown doubl circl infeas node label node fathom branch children fi push onto l. branch condit shown next edg figur algorithm termin empti gap global upper bound lower bound achiev specifi toler level exampl figur follow dfs order start root node blue arrow point next node pop branch updat global lower upper bound node expans shown board branch node learn control polici branch-and-bound good search strategi find good incumb solut earli identifi non-promis node expand howev naiv appli singl heurist whole process ignor dynam structur b b tree exampl dfs use node promis lead good feasibl solut may replac incumb best-boundfirst search quick discard unpromis node use frequent top level tree sinc bound estim accur enough yet therefor propos learn polici adapt differ problem type differ solv stage two goal b b search find optim solut prove optim trade-off two goal may abl return optim solut faster invest time prove solut wors thus aim search good possibl optim solut without rigor proof optim allow us prune unpromis portion search tree aggress addit obtain certif optim usual secondari prioriti practic purpos assum branch strategi bound function given guid search enumer tree two polici recal b b maintain prioriti queue node expand node select polici determin prioriti use onc highest-prior node pop node prune polici decid whether discard expand given current progress solver process continu iter tree empti gap reach specifi toler techniqu use usual branch-and-bound search still appli method process shown figur oracl imit learn requir oracl train time demonstr desir behavior ideal oracl would expand node order minim number node expans subject find optim solut real branch-and-bound system howev optim sequenc expand node obtain without substanti comput effect expand one node depend local inform local bound obtain also mani prune node may lead mani interact strategi branch variabl select therefor given singl goal find good solut quick design oracl find optim solut without proof optim assum optim solut given train problems.1 node select oracl alway expand node whose feasibl set contain optim solut call node optim node exampl figur oracl know beforehand optim solut thus search along edg optim node shown red circl non-optim node fathom node prune oracl alreadi fathom standard rule discuss section denot optim node depth fd root node imit learn formul approach sequenti decision-mak process defin state space action space polici space trajectori consist sequenc state s1 s2 st action a1 a2 polici map state action b b set whole tree node visit far bound comput node node select polici action space select node fi fi queue activ node depend current state st node prune polici binari classifi predict class prune expand given st recent select node polici appli node fathom train time oracl provid optim action possibl state s. goal learn polici mimic oracl action along trajectori state encount polici let fi rp fi rq featur map respect imit problem reduc supervis learn polici classifier/regressor take feature-vector descript state st attempt predict oracl action generic node select polici assign score activ node pop highest-scor one exampl dfs use node depth score best-bound-first search use node lower bound score follow this scheme defin score node wt fi st select node arg maxfi 2l wt fi learn weight vector queue activ node obtain learn linear rank function defin total order set node prioriti queue wt fi fi fi0 train specifi order optim node non-optim node howev test time total order obtain classifi automat general non-optim node close optim node featur space rank higher dagger iter imit learn algorithm repeat retrain polici make decis agre better oracl decis situat encount run past version polici thus learn deal well realist distribut situat may actual aris test time train algorithm shown algorithm algorithm illustr collect exampl b b word push optim node queue want rank higher node current queue push nonoptim node want rank lower optim node queue one note time one optim node queue pop node queue want prune optim left part figur show train exampl collect oracl polici analysi show method follow upper bound expect number branch theorem given node select polici rank non-optim node higher optim node probabl node prune polici expand non-optim node probabl prune optim node probabl assum predict task optim solut usual come free train set otherwis off-theshelf solver use algorithm run b b polici collect exampl problem procedur ollect xampl q train set ds dp while fk pop node fk optim dp dp fk expand els dp dp fk prune fk fathom fk expand expand fk if optim node fn ds ds return ds dp fd fi0 fi0 fd polici state distribut expect number branch let optim node depth fd note push step one optim node queue consid queue one optim node fd non-optim node rank optim one follow lemma use proof lemma averag number pop get fd among number branch nb opt number non-optim node push fd npush opt opt indic situat one optim node queue consid queue no optim node non-optim node mean optim intern node prune optim leaf found we lemma averag number pop empti queue among number branch nb opt opt indic situat no optim node queue proof two lemma given appendix let md fd denot number branch queue empti push fd queue md node total number branch b b process push fd we compar node queue number non-optim node rank follow binomi distribut md md we follow two case fd prune probabl expect number branch nb md opt fd prune probabl we first pop node fd result npush md opt new node after we expand fd get push queue npush md opt md md node thus total expect number branch nb md opt recurs equat md fd emd bin md nb md nb md opt termin we md fd emd bin md nb md opt +nb md md opt nb md opt note we ignor node fathom this recurs path optim node may stop fd thus md fd upper bound actual expect number branch expect md comput replac md md sinc term linear md solv give upper bound theorem detail given appendix b oracl branch time solv problem nonoptim polici all pruning-bas method method bear risk miss optim solut depth first optim node prune follow geometr distribut mean practic we put higher weight class prune learn high-precis classifi smaller experi dataset we appli method lp-base b b solv milp problem we use four problem librari suggest mik2 set milp problem knapsack constraint region hybrid set problem determin winner combinatori auction generat differ distribut combinatori auction test suit cat corlat real dataset use construct wildlif corridor grizzli bear northern rocki region number variabl rang number constraint rang problem set split train test develop set detail dataset present appendix c. problem we run scip optim take singl return solut optim one purpos train we exclud problem solv root experi polici learn problem set we split train set equal-s subset random run dagger one subset iter we taken two pass entir set too mani pass may result overfit polici later iter we use liblinear step train classifi algorithm sinc mistak dure earli stage search serious train place higher weight exampl node closer root polici specif exampl weight level b b tree decay exponenti rate maximum depth4 correspond fact subtre size increas exponenti prune polici train we put higher weight tune class prune counter data imbal learn high-precis classifi discuss earlier class weight svm penalti paramet tune librari develop set featur we use categor three group node featur comput current node includ lower bound5 estim object depth whether child/sibl last process node branch featur comput branch variabl lead current node includ pseudocost differ variabl valu current lp solut root lp solut differ valu current bound tree featur comput b b tree includ global upper lower bound integr gap number solut found whether gap infinit node select polici includ primarili node featur branch featur node prune polici includ primarili branch featur tree featur combin featur depth node we partit tree uniform level featur level stack togeth sinc rang object valu vari larg across problem we normal featur relat bound divid actual valu root node lp object all featur cheap obtain actual use inform record solver thus result much overhead result we compar scip version use cplex lp solver gurobi version scip default node select strategi switch depth-first search best-first search accord plung depth comput onlin gurobi appli differ strategi includ prune subtre root differ node solver adopt branch2 download http //ieor.berkeley.edu/ atamturk/data avail http //www.cs.ubc.ca/ kevinlb/cat rate chosen exampl at depth weight exampl at if node child recent process node lp solv yet bound parent dataset mik region hybrid corlat speed ogap our prune igap speed ogap igap scip time gurobi node ogap ogap igap igap fail fail tabl perform solv milp problem four librari we compar two version algorithm one search prune polici one prune polici scip node limit scip node gurobi time limit gurobi we report result three measur speedup respect scip default set optim gap ogap comput percentag differ best object valu found optim object valu integr gap igap comput percentag differ upper lower bound here fail mean solver find feasibl solut number averag all instanc dataset bold score statist tie best score accord t-test reject threshold and-cut framework combin presolv primal heurist solver implement base scip also call cplex solv lps we compar runtim scip default set termin prove status solv infeas unbound compar tradeoff runtim solut qualiti we first run dynam b b algorithm obtain averag runtim we run scip time limit sinc runtim rather implementation-depend gurobi four time faster scip we use number node explor time measur gurobi gurobi scip appli rough techniqu cutting-plan generat heurist at node we believ fewer node explor impli runtim improv we implement our algorithm base gurobi similar we set gurobi node limit averag number node explor our algorithm result summar tabl our method speed scip factor less loss object found solut dataset corlat loss larger within sinc problem general harder scip gurobi fail find even one feasibl solut given time/nod limit problem note scip default set work better region hybrid gurobi better two while our adapt solver perform well consist this show effect strategi inde problem depend ablat analysi assess effect node select prune separ we report detail classif perform tabel both polici cost neglig time compar total runtim we also show result our method prune polici tabl we see major contribut come prune we believ two main reason may enough inform featur differenti optim node non-optim one effect node select may cover interact techniqu instanc non-optim node could lead better bound due applic cut plane inform featur we rank featur level tree accord absolut valu weight librari although differ problem set specif weight rank featur general pattern closer top tree node select polici prefer node children recent solv node resembl dfs better bound lower level still prefer deeper node also reli pseudocost branch variabl estim node object sinc featur get accur search goe deeper the node prune polici tend prune solut found the gap infinit it also reli much differ the branch variabl valu valu the root lp solut current bound cross general testifi our method learn strategi specif the problem type we appli the learn polici across dataset use polici train dataset solv problem dataset b we plot the result heatmap in figur use measur combin runtim the mik ion corla reg mik hybrid polici dataset region hybrid time opt gap corlat test dataset figur perform polici cross dataset the y-axi show dataset polici train the x-axi show dataset polici test block show runtime+optim gap runtim gap scale for experi the test dataset valu in each row normal the diagon element row dataset prune prune err comp time rate fp fn err selectprun mik region hybrid corlat tabl classif perform the node select prune polici we report the percentag node prune prune rate fals posit fals negat error rate the prune polici comparison error the select polici for comparison one optim one non-optim node well the percentag time use decis make optim gap we invert the valu hotter block in the figur indic better perform note there hot diagon in addit mik corlat relat uniqu polici train dataset lose bad there the hand hybrid more friend polici this probabl suggest for this librari strategi work almost equal well relat work there larg amount work appli machin learn make dynam decis insid long-run solver the idea learn heurist function for combinatori search algorithm date back recent aim balanc load in parallel b b predict the subtre size at each node node the largest predict subtre size split smaller problem sent the distribut environ node in a batch in a svm classifi use decid if probe bound tighten techniqu use at a node in b b howev both prior method handl a relat simpl set the model predict inform the current state simpli train standard supervis learn this manifest the case for us sinc action influenc futur state standard supervis learn work well dagger imit learn techniqu focus situat most like encount at test time our work also close relat speedup learn the learner observ a solver solv problem learn pattern past experi speed futur comput learn rank function control beam search set similar our in plan structur predict respect use supervis learn imit strong branch in b b for solv mip the primari distinct in our work we explicit formul the problem as a sequenti decision-mak process thus take aciton effect on futur account we also add the prune step besid priorit for speedup conclus we present a novel approach learn an adapt node search order for differ class problem in branch-and-bound algorithm our dynam solver learn leav an unpromis area when to stop for a good enough solut we demonstr on multipl dataset compar to a commerci solver our approach find solut a better object establish a smaller gap use less time in the futur we intend to includ a time budget in our model we achiev a user-specifi trade-off solut qualiti search time we also interest in appli multi-task learn to transfer polici differ dataset
----------------------------------------------------------------

title: 312-bumptrees-for-efficient-function-constraint-and-classification-learning.pdf

bumptre effici function constraint classif learn stephen m. omohundro intern comput scienc institut center street suit berkeley california abstract new class data structur call bumptre describ structur use effici implement number neural network relat oper empir comparison radial basi function present robot ann map learn task applic densiti estim classif constraint represent learn also outlin bumptre bumptre new geometr data structur use effici learn repres evalu geometr relationship varieti context natur general sever hierarch geometr data structur includ oct-tre k-d tree balltre boxtre they use mani geometr learn task includ approxim function constraint surfac classif region probabl densiti sampl function approxim case approach relat radial basi function neural network support faster construct faster access flexibl modif provid empir data compar bumptre radial basi function section bumptre use provid effici access collect function euclidean space interest complet binari tree leaf correspond function interest also function associ intern node defin constraint interior node 's function must everwher larger omohundro function associ leav beneath mani case leaf function peak locali7.. region origin name simpl kind bump function spheric symmetr center vanish outsid specifi ball figur show structur two-dimension bumptre set ball support bump leaf function abc tree structur tree function figur two-dimension bumptre particular import special case bumptre use access collect gaussian function multi-dimension space collect use exampl repres smooth probabl distribut function gaussian mixtur aris mani adapt kernel estim scheme conveni repres quadrat expon gaussian tree rather gaussian simplest approach use quadrat function intern node well leav shown figur though class intern node function sometim provid faster access abc figur bumptre hold gaussian mani hierarch geometr data structur may seen special case bumptre choos appropri intern node function shown figur region may repres function take valu insid region vanish outsid function shown figur 3d align along coordin axi constant one side specifi valu decreas quadrat side repres specifi coordin cut cut locat constant valu situat coeffici quadrat decreas function may evalu extrem effici data point use fast prune oper evalu effect use sproull implement fast nearest neighbor comput bumptre structur general kind queri allow differ scale differ point direct empir result present next section base bumptre kind intern node function bumptre effici function constraint classif learn a. cy b. d. figur intern bump function oct-tre kd-tree boxtre omohundro balitre omohundro sproull 's higher perform kd-tree sproull there sever approach choos tree structur build given leaf data algorithm studi balltre construct omohundro may appli general task bumptre construct fastest approach analog basic k-d tree construct techniqu friedman al top recurs split function two set almost size what use simul describ next section slowest effect approach build tree bottom greedili decid best pair function join singl parent node intermedi speed qualiti increment approach allow one dynam insert delet leaf function bumptre may use effici support mani import queri simplest kind queri present point space ask leaf function valu point larger specifi valu bumptre allow search root prune subtre whose root function smaller specifi valu point interest queri base branch bound general nearest neighbor queri k-d tree support typic exampl case collect gaussian request gaussian set whose valu specifi point within specifi factor say gaussian whose valu largest point search proceed promis branch rust continu maintain largest valu found point prune away subtre within given factor current largest function valu robot map learn task system kinemat space r3 visual space r6 figur robot arm map task omohundro figur show setup defin map learn task use studi effect balltre data structur setup investig extens mel involv camera look robot arm kinemat state ann defm three angl control coordin visual state six visual coordin highlight spot arm map kinemat visual space nonlinear map three dimens six system attempt learn map flail ann around observ visual state varieti random chosen kinemat state set random input/output pair system must general map input seen map task chosen fair repres typic problem aris vision robot radial basi function approach map learn repres function linear combin function spheric symmetr around chosen center wjg xj simplest form use basi function center input point recent variat fewer basi function sampl point choos center cluster time result given would term number basi function rather number sampl point variat type mani fonn basi function suggest studi gaussian linear increas function gave similar result coeffici radial basi function chosen sum form least squar best fit data fit requir time proport cube number paramet general experi report done use singular valu decomposit comput best fit coeffici approach map learn base bumptre build local model map region space use data associ train sampl nearest region local model combin convex way accord influenc function associ model influenc function peak region salient bumptre structur organ local model model great influenc queri sampl need evalu if influenc function vanish outsid compact region tree use prune branch influenc if model 's influenc mere die distanc branch bound techniqu use determin contribut greater specifi error bound if set bump function sum one point region interest they call partit uniti fonn influenc bump divid set smooth bump either gaussian smooth bump vanish outsid sphere sum form easili comput partiton uniti our local model affin function determin least squar fit local sampl these combin accord partit uniti valu point convex combin local model valu error full model therefor bound error local model yet full approxim smooth local bump function these result may use give precis bound averag number sampl need achiev given approxim error function bound second deriv approach linear fit done small set local sampl avoid comput expens fit whole data set requir radial basi function local also allow us easili updat model onlin new data arriv bumptre effici function constraint classif learn if bi bump function such gaussian ftj bi x fonn partit lbj x uniti if local affin model final smooth interpol approxim function lfti x mi x influenc bump center sampl point width determin sampl densiti affin model associ influenc bump detennin weight least squar fit sampl point nearest bwnp center weight decreas distanc becaus it perform global fit given number sampl point radial basi function approach achiev smaller error approach base bumptre term construct time achiev given error howev bwnptree clear winner.figur show mean squar error robot arm map task decreas function time construct map mean squar error learn time see figur mean squar error function learn time perhap even import applic learn time retriev time retriev use radial basi function requir valu basi function comput queri input these result combin accord best fit weight matrix this time increas linear function number basi function represent bumptre approach influenc bump affin model prune away bumptre retriev need perform comput input figur show retriev time function number train sampl robot map task retriev time radial basi function cross balltre sampl increas linear graph balltre algorithm retriev time empir grow slowli n't requir much time even sampl repres while shown represent may improv size general capac best first merg techniqu idea consid merg two local model influenc bump singl model the pair increas the error the least omohundro merg frrst the process repeat pair left whose meger would n't exceed error criterion this algorithm good job discov repres linear part map singl model put mani higher resolut model area strong nonlinear retriev time see gaussian rbf bumptre 2k 4k 6k 8k figur retriev time function number train sampl extens task the bumptre structur use implement effici version varieti geometr learn task omohundro perhap the fundament such task densiti estim attempt model probabl distribut space the basi sampl drawn distribut one power techniqu adapt kernel estim devroy gyorfi the estim distribut repres gaussian mixtur spheric symmetr gaussian center data point the width chosen accord the local densiti sampl best-first merg techniqu may often use produc mixtur consist mani fewer non-symmetr gaussian bumptre may use fmd organ such gaussian possibl intern node function includ quadrat the faster evalu function shown figur it possibl effici perform mani oper probabl densiti repres in this way the basic queri return the densiti given locat the bumptre may use branch bound achiev retriev in logarithm expect time it also possibl quick fmd margin probabl integr along certain dimens the tree use quick identifi the gaussian contribut condit distribut may also repres in this form bumptre may use compos two such distribut we discuss map learn evalu in mani situat there the natur input output variabl requir map if a probabl distribut peak a lower dimension surfac it may thought a constraint network bumptre effici function constraint classif learn constraint may impos in order among variabl natur describ mani problem bumptre open sever possibl effici repres propag smooth constraint continu variabl the basic queri specifi known extern constraint certain variabl allow the network impos whatev constraint it multi-dimension product ganssian use repres joint rang in a set variabl the oper impos a constraint surfac may thought multipli an extern constraint gaussian the function repres the constraint distribut becaus the product two gaussian a gaussian this oper alway produc gaussian mixtur bumptre may use facilit the oper a represent constraint more like use map consbuct surfac local affin patch weight influenc function we develop a local analog principl compon analysi build surfac random sampl drawn as the map structur a best-frrst merg oper may use discov affin sbuctur in a constraint surfac final bumptre may use enhanc the perform classifi one approach is direct implement bay classifi use the adapt kernel densiti estim describ abov each class distribut function a separ bumptre may use each class a more sophist branch bound a singl tree may use the whole set class in summari bumptre a natur general sever hierarch geometr access structur may use enhanc the perform mani neural network like algorithm while we compar radial basi function a differ map learn techniqu bumptre may use boost the retriev perform radial basi function direct when the basi function decay away from center mani other neural network approach in much the network perform use work everi queri also suscept to sometim dramat speedup the use this kind access sbuctur
----------------------------------------------------------------

title: 1625-unsupervised-and-supervised-clustering-the-mutual-information-between-parameters-and-observations.pdf

unsupervis supervis cluster mutual inform paramet observ didier herschkowitz jean-pierr nadal laboratoir de physiqu statistiqu de l'e.n. ecol normal superieur rue lhomond pari cedex franc herschko lps.ens.fr nadal lps.ens.fr http //www.lps ens.frrrisc/rescomp abstract recent work paramet estim neural code demonstr optim perform relat mutual inform paramet data consid mutual inform case depend paramet vector condit observ vector scalar product deriv bound asymptot behaviour mutual inform compar result obtain model replica techniqu introduct contribut consid unsupervis cluster task recent result neural code paramet estim supervis unsupervis learn task show mutual inform data paramet equival neural activ stimulus relev tool deriv optim perform clark barron nadal parga opper kinzel haussler opper opper haussler rissanen brunei nadal laboratori associ en univers pari vi pari vii mutual inform paramet observ tool analyz particular case studi extens replica echniqu framework statist mechan watkin nadal reimann van den broeck buhot gordon after introduc model next section consid mutual inform pattern paramet deriv bound interest larg show free energi associ gibb learn relat mutual inform compar exact result replica calcul show asymptot behaviour mutual inform agreement exact result known relat fish er inform clark barron rissanen brunei nadal howev moder valu pin elimin fals solut replica calcul final give bound relat mutual inform paramet estim discuss common featur paramet estim neural code model we consid problem direct unit vector dimens found base observ pattern probabl distribut pattern uniform except unknown symmetry-break direct various instanc problem studi recent within satist mechan framework make use replica techniqu watkin nadal reimann van den broeck buhot gordon more specif assum set pattern generat independ sampl non-uniform probabl distribut ol repres symmetry-break orient probabl written form o/ ex dimens space overlap character structur data break direct justifi within bayesian statist physic framework one consid prior distribut paramet space uniform distribut sphere mutual inform j dio data defin rewritten j dio dop o exp j.l=l statist physic literatur free energi bracket stand averag pattern distribut averag result overlap distribut we consid properti valid nand other replica calcul valid nand larg given valu d. herschkowitz nadal linear bound mutual inform posit quantiti grow faster linear amount data we deriv simpl linear bound we proov inequ case extens case straightforward mutual inform written h dib calcul h dib straightforward h dib now entropi data ddp d lnp d lower equal entropi gaussian distribut varianc we thus calcul covari matrix data 6ij denot averag paramet distribut pn we i=l i eigen valu matrix bib use l i bt properti i=l we obtain put togeth we find inequ l.from follow also replica calcul limit finit free energi becom self-averag equal averag calcul perform standard replica techniqu calcul calcul relat gibb learn done reimann van den broeck buhot gordon interpret order paramet differ assum replica symmetri we reproduc fig.2 result buhot gordon behaviour typic overlap two direct compat data overlap distribut chosen get pattern distribut accord two cluster along symmetry-break direct exp fig.2 fig.1 we show correspond behaviour averag free energi mutual inform mutual inform paramet observ discuss ai mutual inform pure linear phase correspond regim data correl ai replica calcul admit three differ solut view fact mutual inform never decreas averag free energi posit follow two behaviour accept first leav solut ai follow lower branch jump upper branch stabl way second possibl a2 direct jump upper branch buhot gordon suggest one reach upper branch well we thus shown it possibl it remain also possibl replica symetri breack phase in rang in limit inform replica calculus give behaviour mutual i dio in r.h.s shown equal half logarithm determin fish er inform matrix exact asymptot behaviour clark barron brunei nadal it shown behaviour impli best possibl estim base data satur cramer-rao bound blahut it alreadi note asymptot perform in estim direct comput replica techniqu satur bound van den broeck what we check here manifest in behaviour mutual inform larg bound specif estim given data one want find estim paramet amount inform i dio limit perform estim inde one i jio i dio basic relationship allow deriv interest bound base choic particular estim we consid first gibb learn consist in sampl direct posteriori probabl p jid p dij p j in this particular case differenti entropi ofth estim paramet equal if qg varianc gibb estim one get gaussian prior relat relat togeth linear bound allow bound order paramet qg small this bound interest bay estim consist in take center mass posteriori probabl in limit this distribut becom gaussian center probabl valu we thus assum pbay jio gaussian mean qbb varianc qb first inequ in qg replac qb gibb bay equal then use cramer-rao bound varianc the estim one bound the mutual inform the bay estim ibay es jib d. herschkowitz j-p. nadal these differ quantiti shown conclus we studi the mutual inform data paramet in problem unsupervis cluster deriy bound asymptot behaviour compar these result replica calcul most the result concern the behaviour the mutual inform observ this particular cluster task univers in qualit the problem formul as either paramet estim task neural coding/sign process task in particular linear regim small enough amount data number code cell up a maxim valu relat the vc dimens the system for larg data size the behaviour logarithm i lnp nadal parga opper haussler lnp clark barron opper haussler brunei nadal depend on the smooth the model a more detail review with more univers featur exact bound relat unsupervis supervis learn present elsewher nadal herschkowitz appear in phys rev e acknowledg we thank arnaud buhot mirta gordon for stimul discuss this work part support the french contract dga a/dsp
----------------------------------------------------------------

title: 5159-global-map-optimality-by-shrinking-the-combinatorial-search-area-with-convex-relaxation.pdf

global map-optim shrink combinatori search area convex relax bogdan savchynskyy1 j org kappes2 paul swoboda2 christoph schn orr1,2 heidelberg collaboratori imag process heidelberg univers germani bogdan.savchynskyy iwr.uni-heidelberg.d imag pattern analysi group heidelberg univers germani kapp swoboda schnoerr math.uni-heidelberg.d abstract consid energi minim undirect graphic model also known map-infer problem markov random field although combinatori method return provabl optim integr solut problem made signific progress past decad still typic unabl cope large-scal dataset hand larg scale dataset often defin spars graph convex relax method linear program relax provid good approxim integr solut propos novel method combin combinatori convex program techniqu obtain global solut initi combinatori problem base inform obtain solut convex relax method confin applic combinatori solver small fraction initi graphic model allow optim solv much larger problem demonstr efficaci approach comput vision energi minim benchmark introduct focus paper energi minim markov random field common pairwis case problem read min min xv uv xu xv x xg x xg v vg uv eg vg eg denot undirect graph set node vg set edg eg uv variabl xv belong finit label set xv vg potenti xv uv xu xv vg uv eg associ node edg respect denot xg cartesian product v vg xv problem known np-hard general henc exist method either consid convex relax or/and appli combinatori techniqu branch-and-bound combinatori search cut plane etc top convex relax main contribut paper novel method combin convex combinatori approach comput provabl optim solut method general sens restrict specif convex program combinatori algorithm although algorithm prefer other main restrict method neighborhood structur graph spars basic grid graph imag data provid exampl satisfi requir method applic also higher-ord problem defin call factor graph howev concentr main pairwis case keep exposit simpl under idea demonstr main idea method let two subgraph cover g. select common node subgraph lie mutual border label mismatch solv separ check consist increas figur under idea propos method initi graph split two subgraph blue+yellow red+yellow assign convex combinatori solver respect if integr solut provid solver coincid common border yellow two subgraph subgraph increas append mismatch node green border adjust respect defin term master-graph g. let x x b optim label comput independ b if label coincid border addit condit concaten x x b optim label initi problem we show section theorem we select subgraph contain a simpl part problem convex relax tight part assign respect convex program solver subgraph contain contrast difficult combinatori subproblem assign a combinatori solver if label x a x b coincid border node we increas subgraph append node edg correspond decreas a iii recomput x a x b this process repeat either label x a x b coincid border equal g. sparsiti requir avoid fast growth subgraph b we refer section a detail descript algorithm we particular specifi initi select subgraph a method encourag consist x a x b boundari a provid equival result a singl run convex relax solver techniqu describ local polytop relax known also a linear program relax relat work literatur problem broad regard convex program combinatori method here we concentr local polytop relax essenti approach local polytop relax propos analyz also recent review an altern view relax propos this view appear close idea lagrangian dual decomposit techniqu applic this idea stimul develop effici solver convex relax scalabl solver lp relax becam a hot topic recent year algorithm howev guarante attain optimum convex relax least theoret quit slow practic see comparison remark fastest scalabl algorithm convex relax base coordin descent diffus algorithm known seventi especi dual decomposit base variant trw-s there close relat method base on principl although algorithm guarante attain optimum converg point fulfil a condit known arc consist weak tree agreement we show section this condit play a signific role approach it a common observ case spars graph and/or strong evid the unari term vg the approxim solut deliv solver quit good the practic viewpoint the belief solut close optim one evidenc numer bound these solver provid a byproduct the techniqu use in combinatori solver special problem includ the classic tool cut plane combinatori search branch-and-bound method adapt the problem the idea the cut plane method form the basi tighten the lp relax within the dual decomposit framework the recent review
----------------------------------------------------------------

title: 3135-branch-and-bound-for-semi-supervised-support-vector-machines.pdf

branch bound semi-supervis support vector machin olivi chapelle1 max planck institut ubingen germani chapell tuebingen.mpg.d vika sindhwani univers chicago chicago usa vikass cs.uchicago.edu s. sathiya keerthi yahoo research santa clara usa selvarak yahoo-inc.com abstract semi-supervis svms vm attempt learn low-dens separ maxim margin label unlabel exampl associ optim problem non-convex examin full potenti s3 vms modulo local minima problem current implement appli branch bound techniqu obtain exact global optim solut empir evid suggest global optim solut return excel general perform situat implement fail complet current implement applic small dataset discuss variant potenti lead practic use algorithm introduct major line research extend svms handl partial label dataset base follow idea solv standard svm problem treat unknown label addit optim variabl maxim margin presenc unlabel data one learn decis boundari travers low data-dens region respect label input space word approach implement cluster assumpt semi-supervis learn point data cluster similar label idea first introduc name transduct svm sinc learn induct rule defin entir input space refer approach semisupervis svm vm sinc first implement wide spectrum techniqu appli solv non-convex optim problem associ s3 vms local combinatori search gradient descent continu techniqu convex-concav procedur determinist anneal non-convex part respons divers method also departur one nicest featur svms sever experiment studi establish s3 vm implement show vari degre empir success conjectur close tie suscept local minima problem follow question motiv paper how well current s3 vm implement approxim exact global optim solut non-convex problem associ s3 vms one expect signific improv general perform better approach global solut believ question fundament import s3 vm research larg unresolv part due lack simpl implement practition use benchmark new algorithm global solut even small-siz problem part yahoo research chap yahoo-inc.com contribut paper outlin class branch bound algorithm guarante provid global optim solut s3 vms branch bound techniqu previous note context s3 vm detail present implement evalu branch bound strategi serv upper baselin s3 vm algorithm strategi practic typic semisupervis set larg amount unlabel data avail believ open new avenu research potenti lead effici variant empir result semi-supervis task present section show exact solut found branch bound excel general perform s3 vm implement perform poor result also show s3 vm compet even outperform graph-bas techniqu problem latter class method typic excel semi-supervis support vector machin consid problem binari classif train set consist label exampl unlabel exampl linear case follow object function minim hyperplan paramet label vector yu yn min w b yu ip ip constraint non linear decis boundari construct use kernel trick while general convex loss function use common either penal train error linear quadrat rest paper consid first two term correspond standard svm last one take account unlabel point seen implement cluster assumpt low densiti separ assumpt inde drive output unlabel point away figur loss sign output figur loss point label sign output unlabel point mini simplic take c. practic import set two valu independ reflect confid label train point while correspond belief low densiti separ assumpt addit add follow balanc constraint max yi constraint necessari avoid unbalanc solut also use origin implement ideal paramet set ratio posit point unlabel set sinc unknown usual estim class ratio label set case one may wish soften constraint sake simplic rest paper set true ratio posit point unlabel set let us call object function minim yu two main strategi minim given fix optim yu simpli given sign continu optim done note constraint straightforward enforc given yu optim standard svm train let defin yu min yu w b goal minim set binari variabl evalu standard svm train approach follow one take paper constraint implement set yu vector yu satisfi branch bound branch bound basic suppos want minim function space usual discret branch bound algorithm two main ingredi branch region recurs split smaller subregion yield tree structur node correspond subregion bound consid two disjoint subregion node suppos upper bound say best valu known lower bound say best valu known know element subset better element b search global minim safe discard element search subtre correspond prune branch bound s3 vm aim minim 2u possibl choic vector yu constitut set introduc binari search tree follow structur node correspond partial label data set two children correspond label unlabel point one thus associ node label set contain origin label exampl subset unlabel exampl yj label yj assign one also associ unlabel set correspond subset unlabel point assign label yet size subtre root node thus root tree origin set label exampl associ i.e empti leav tree correspond complet label dataset empti node correspond partial label ani branch bound algorithm decid follow choic branch given node tree partial label unlabel set two children unlabel point label next bound upper lower bound use explor order search tree examin word subtre explor next note tree built explicit fli explor actual ur effect choic constraint concern upper bound decid follow simpl strategi leaf node upper bound simpli valu function non leaf node there upper bound word upper bound best object function found far come back notat section set leaf correspond best solut found far set subtre consid explor choic upper bound natur way explor tree depth first search inde import go leav often possibl order tight upper bound thus perform aggress prune choic lower bound branch strategi present next lower bound consid simpl lower bound base follow observ minimum object function smaller correspond standard svm ignor unlabel data therefor comput lower bound given node optim standard svm label set associ node present general framework comput lower bound base dual object function svms let yu dual object function yu correspond label unlabel point assign label yet yu yj k xi 2c dual feasibl now suppos strategi given yu find vector satisfi sinc dual maxim yu max yu yu defin let q yu yu lb lower bound valu min q yu minimum taken yu satisfi balanc constraint lb also lower bound valu object function correspond node goal thus find choic lower bound comput effici choic correspond lower bound present follow train svm label point obtain vector complet zero unlabel point q yu possibl label unlabel point lower bound svm object function label point sketch anoth possibl one explor instead complet vector zero complet constant would typic order magnitud q yu hy hij kij lower bound one use result quadrat zero-on program literatur solv constrain eigenvalu problem final note unless constraint satisfi one remedi train supervis svm constraint 2ru primal amount penal bias term branch given node unlabel point alreadi assign label unlabel point label next sinc strategi reach good solut soon possibl last paragraph section seem natur assign label confid simpl possibl would branch unlabel point nearest anoth label point use reliabl distanc metric now present principl approach base analysi object valu say confid particular label unlabel point assign opposit label result big increas object valu partial solut would then unlik lead optim one let us formal strategi rememb section node associ set current label exampl set unlabel exampl let svm object function train label set min w b discuss previous section lower bound now branch strategi consist select follow point arg max l word want find unlabel point label would make object function increas much possibl then branch but start explor branch like label strategi intuit link label propag idea unlabel point which near label point like label otherwis object function would larg main disadvantag approach solv lot svm train necessari howev possibl approxim comput l idea similar fast approxim leave-one-out solut situat add-one-in svm train set possibl effici comput solut one point ad train set assumpt set support vector chang ad point practic set like chang solut approxim proposit consid train svm label set quadrat penal error cf let learn function sv set support vector then sv chang while ad point train set yf l sx2 sv k xi 2c x i sv ksv i j sv ksv ysv proof omit becaus lack space base fact ysv reli block matrix invers formula algorithm algorithm implement recurs algorithm begin upper bound either set solut found anoth algorithm note svm train increment whenev go tree one point ad in label set reason retrain done effici also see sinc effect we need updat invers matrix experi we consid here two dataset s3 vm implement unabl achiev satisfi test error rate this natur rais follow question this weak per algorithm branch bound s3 vm bb function s3 vm y ub recurs implement input part label vector unlabel ub upper bound optim object valu output optim fulli label vector correspond object function yi ur yi ur then return constraint satisfi end explor this subtre svm y comput svm object function label point ub then return lower bound higher upper bound end explor this subtre fulli label then return we leaf end find index label in find next unlabel point label yi start first like label s3 vm y ub find recurs best solut yi yi switch label v2 s3 vm y min ub explor branch updat upper-bound v2 then v2 keep best solut end formanc due unsuit s3 vm object function problem do method get stuck at high sub-optim local minima two moon two moon dataset now standard benchmark semi-supervis learn algorithm graph-bas method easili solv this problem but so far all s3 vm algorithm find difficult construct right boundari except use l1 loss we drew random realize this dataset fix bandwidth rbf kernel set each moon contain unlabel point we compar cs3 cccp svmlight da first method there direct way enforc constraint howev method constraint mean output unlabel point equal constant this constant normal fix mean label but sake consist we dichotomi search this constant in order satisfi result present in tabl note test error for s3 vm implement like improv hyperparamet tune but still stay high for comparison we also includ result state-of-the-art graph base method lapsvm whose hyperparamet optim for test error threshold adjust satisfi constraint matlab sourc code demo algorithm two moon dataset access supplementari materi this paper coil extens benchmark result report in benchmark chapter show problem class expect resid low-dimension non-linear manifold handwritten digit graph-bas algorithm signific outperform s3 vm implement tabl result two moon dataset averag random realize vm cs3 vm cccp svmlight da bb lapsvm test error object function n/a we consid here dataset select three confus class coil20 dataset figur there imag per class correspond rotat degre thus yield a one dimension manifold we random select imag per class in label set rest unlabel result report in tabl hyperparamet chosen figur car coil dataset subsampl tabl result the coil dataset averag random realize vm cs3 vm cccp svmlight da bb lapsvm test error object function n/a tabl it appear clear the s3 vm object function lead excel test error s3 vm implement fail complet in find a good minimum the object function2 the global s3 vm solut actual outperform graphbas altern even s3 vm implement found competit concern the run time it the order a minut for dataset we do expect this algorithm abl handl dataset much larger coupl hundr point discuss conclus we implement evalu one strategi amongst mani in the class branch bound method find the global optim solut s3 vms the work the close relat method howev paper present algorithm for linear s3 vms reli generic mix integ program which make use the problem structur method this basic implement perhap made effici choos better bound branch scheme also by fix the upper bound the current best object the report test error somehow irrelev use for rank the differ algorithm they interpret as failur valu we restrict implement follow depth-first search it conceiv breadth-first search equal or effect in conjunct with altern upper bound scheme prune done aggress speed-up termin at the expens obtain a solut suboptim within toler prune if a final we note a larg famili well-test branch bound procedur from zeroon quadrat program literatur immedi appli the s3 vm problem for the special case squar loss an interest open question whether one provid a guarante for polynomi time converg assumpt the data the kernel concern the run time our current implement we observ it effici whenev the global minimum signific smaller most local minima in case the tree can prune effici this happen the cluster well separ small for these reason we believ this implement scale to larg dataset but instead consid as a proof concept the s3 vm object function is well suit for semi-supervis learn effort made tri to effici find good local minima
----------------------------------------------------------------

title: 5189-despot-online-pomdp-planning-with-regularization.pdf

despot onlin pomdp plan regular adhiraj somani nan ye david hsu wee sun lee depart comput scienc nation univers singapor adhirajsomani gmail.com yenan dyhsu leew comp.nus.edu.sg abstract pomdp provid principl framework plan uncertainti comput intract due curs dimension curs histori paper present onlin pomdp algorithm allevi difficulti focus search set random sampl scenario determin spars partial observ tree despot compact captur execut polici scenario regular despot r-despot algorithm search despot polici optim balanc size polici estim valu obtain sampl scenario give output-sensit perform bound polici deriv despot show r-despot work well small optim polici exist also give anytim algorithm approxim r-despot experi show strong result compar two fastest onlin pomdp algorithm sourc code along experiment set avail http //bigbird.comp nus.edu.sg/pmwiki/farm/appl introduct partial observ markov decis process pomdp provid principl general framework plan partial observ stochast environ howev pomdp plan comput intract worst case challeng aris three main sourc first pomdp may larg number state second state fulli observ agent must reason belief probabl distribut state rough size belief space grow exponenti number state final number actionobserv histori must consid pomdp plan grow exponenti plan horizon first two difficulti usual refer curs dimension last one curs histori address difficulti onlin pomdp plan survey choos one action time interleav plan plan execut time step agent perform d-step lookahead search plan immedi next action current belief reason neighborhood current belief rather entir belief space work adopt onlin plan approach recent onlin pomdp plan algorithm call pomcp success scale larg pomdp pomcp base mont carlo tree search tri break two curs sampl state current belief sampl histori black-box simul use uct algorithm control exploration-exploit trade-off onlin lookahead search howev uct sometim over greedi suffer worst-cas perform exp exp sampl find suffici good action paper present new algorithm onlin pomdp plan enjoy strength pomcp break two curs sampl avoid pomcp extrem poor worst-cas behavior evalu polici small number sampl scenario plan step algorithm search good polici deriv determin spars partial observ tree despot current belief execut polici one step despot summar execut polici sampl scenario structur similar standard belief tree contain belief node reachabl scenario composit exponenti function a1 o2 o1 o1 a2 a1 a2 o2 o1 o2 o1 o1 o2 a1 a2 o2 o1 o2 figur view despot spars sampl belief tree belief tree height contain node size action set observ set respect correspond despot contain node lead dramat improv comput effici small one main result work output-sensit bound show small number sampl figur belief tree height gray scenario suffici give good estim correspond despot black obtain sampl scenario everi tree node repres true valu polici provid size small section regubelief everi color dot repres scenario lariz despot r-despot algorithm interpret lower bound regular util function use optim balanc size polici estim perform sampl scenario show r-despot comput near-optim polici whenev small optim polici exist section anytim onlin plan give heurist approxim anytim regular despot ar-despot r-despot algorithm section experi show strong result ar-despot compar two fastest onlin pomdp algorithm section relat work there two main approach pomdp plan offlin polici comput onlin search offlin plan agent comput beforehand polici conting upon possibl futur scenario execut comput polici base observ receiv although offlin plan algorithm achiev dramat progress comput near-optim polici difficult scale larg pomdp exponenti number futur scenario must consid contrast onlin plan interleav plan plan execut agent search singl best action current belief execut action updat belief process repeat new belief recent survey list three main categori onlin plan algorithm heurist search branch-and-bound prune mont carlo sampl ar-despot contain element three idea construct despot determinist sampl relat howev ar-despot balanc size polici estim perform onlin search result improv perform suitabl plan task onlin search algorithm includ base mont carlo sampl explicit repres belief probabl distribut state space howev limit scalabl larg state space singl belief updat take time quadrat number state contrast despot algorithm repres belief set particl pomcp perform belief updat dure onlin search onlin search offlin polici comput complementari combin use approxim partial polici comput offlin default polici bottom search tree onlin plan macro-act shorten search horizon determin spars partial observ tree pomdp preliminari pomdp formal tupl set state set action set observ s0 probabl transit state s0 agent take action state probabl observ agent take action end state immedi reward take action state pomdp agent know true state receiv observ provid partial inform state agent maintain belief often repres probabl distribut s. start initi belief b0 time updat belief bt accord bay rule incorpor inform action taken time result observ bt zt polici specifi action belief b valu polici beliefp expect total discount reward obtain follow initi b0 discount factor belief one way onlin pomdp plan construct belief tree figur current belief b0 initi belief root tree perform lookahead search tree polici maxim node tree repres belief node branch action edg action edg branch observ edg node child repres belief b0 respect b0 z search belief tree typic truncat maximum depth perform post-ord travers leaf node simul default polici obtain lower bound valu intern node appli bellman principl optim choos best action nx max v z z recurs comput maximum valu action branch averag valu observ branch result approxim optim polici repres polici tree correspond valu polici tree retain chosen action branch observ branch belief tree2 size polici number tree node algorithm repres belief set particl sampl state start initi belief time step search polici describ agent execut first action receiv new observ appli particl filter incorpor inform updat new belief process repeat despot standard belief tree captur execut polici possibl scenario despot captur execut polici set sampl scenario figur contain action branch observ branch sampl scenario defin despot construct appli determinist simul model possibl action sequenc scenario sampl initi belief b0 scenario abstract simul trajectori start state s0 formal scenario belief random sequenc start state s0 sampl accord real number sampl independ uniform rang determinist simul model function random number distribut uniform distribut accord s0 simul model action sequenc a2 a3 scenario simul generat trajectori a1 s1 z1 a2 s2 z2 st zt simul trajectori trace path z1 a2 z2 root standard belief tree add node edg path despot despot node contain set consist scenario encount start state scenario form particl set repres approxim insert scenario set insert st set bt belief node bt reach end subpath z1 a2 z2 zt repeat process everi action sequenc everi sampl scenario complet construct despot despot determin complet scenario sampl random priori intuit despot standard belief tree observ branch remov while belief tree height node correspond despot node reduc observ branch sampl scenario henc name determin spars partial observ tree despot evalu polici sampl scenario defin total discount reward trajectori obtain simul scenario estim valu set scenario appli usual belief tree search previous subsect despot find polici good perform sampl scenario call algorithm basic despot b-despot idea use sampl scenario plan exploit hindsight optim well ho plan scenario independ build separ tree node contrast despot captur scenario singl tree node allow us reason scenario simultan reason despot provid stronger perform guarante ho polici tree repres compact label node action edg follow remov action edg use represent regular despot search despot near-optim polici b-despot choos best action everi intern node despot accord scenario encount howev may caus overfit chosen polici optim sampl scenario perform well general mani scenario sampl reduc overfit our r-despot algorithm leverag idea regular balanc estim perform polici sampl scenario polici size subtre despot node larg perform polici subtre may estim reliabl scenario instead search subtre polici r-despot termin search use simpl default polici node onward deriv r-despot start two theoret result first one provid output-sensit lower bound perform arbitrari polici deriv despot impli despit sparsiti despot contain suffici inform approxim polici evalu accuraci depend size polici second result show optim bound find polici small size high valu conveni assum rmax result easili extend accommod negat reward proof result avail supplementari materi formal polici tree deriv despot contain root despot one action branch intern node let denot class polici tree deriv despot height construct sampl scenario belief b0 like despot polici tree may contain observ branch execut encount observ branch present simpli follow default polici similar follow default polici reach leaf node bound error estim valu polici deriv despot theorem everi polici tree satisfi rmax probabl least estim valu set random sampl scenario belief b0 second term right hand side rhs captur addit error estim valu polici tree depend size make error arbitrarili small choos suitabl larg number sampl scenario furthermor error grow logarithm indic approxim scale well larg action observ set constant tune tighten bound smaller valu allow first term rhs approxim better increas addit error second term specif construct bound multiplicative-addit form due haussler order appli effici dynam program techniqu r-despot natur idea search near-optim polici maxim rhs guarante perform account estim perform size theorem let optim polici belief b0 let polici deriv despot height construct random sampl scenario belief b0 maxim rmax among polici deriv despot rmax probabl least theorem impli small optim polici tree exist find near-optim polici high probabl maxim note global optim polici b0 may may lie express rewritten form similar regular util function mani machin learn algorithm describ r-despot consist two main step first r-despot construct despot height use scenario b-despot improv onlin plan perform may use offlin learn optim valu k. second r-despot perform bottom-up dynam program deriv polici tree maxim given polici tree deriv despot defin regular weight discount util rwdu node v b number scenario pass node discount factor depth tree subtre root fix constant regular util simpli comput recurs ab b0 ab ab ab chosen action node ch set child node start state associ scenario now describ dynam program procedur search optim polici belief node let maximum rwdu polici tree deriv comput recurs leaf node default polici otherwis max max ch b set child node action branch first maxim choos execut default polici expand subtre second maxim choos among differ action avail valu optim polici despot root belief b0 comput bottom-up dynam program time linear size anytim regular despot improv onlin plan perform large-scal pomdp introduc ardespot anytim approxim r-despot ar-despot appli heurist search branchand-bound prune uncov promis part despot search partial construct despot polici maxim regular util theorem brief summari ar-despot given algorithm below provid detail ar-despot perform heurist search section construct upper lower bound branchand-bound prune section despot construct forward search ar-despot increment construct despot use heurist forward search initi contain root node associ belief b0 set scenario sampl accord b0 make seri trial augment trace path root leaf ad new node end path everi belief node maintain upper bound lower bound valu optim polici set scenario similar maintain bound b0 q-valu b0 trial start root step choos action branch maxim current node choos observ branch maxim weight excess uncertainti child node b0 weu b0 excess b0 excess b0 constant specifi desir gap upper lower bound root b0 chosen node negat algorithm ar-despot set b0 initi belief loop uild espot comput optim polici run rial b return leaf node expand one level deeper insert new node children arg maxa arg maxz zb weu weu b then return run rial b els return ing execut first action receiv observ updat belief b0 uild espot b0 sampl set random scenario b0 insert b0 root node while time permit run rial back upper lower bound everi node path b0 return excess uncertainti trial end otherwis continu reach leaf node we then expand leaf node one level deeper ad new belief node everi action everi observ children final we trace path backward root perform backup upper lower bound node along way lower-bound backup max z zb zb set observ encount action taken scenario upper bound backup we repeat trial long time permit thus make algorithm anytim initi upper bound there sever approach construct initi upper bound at node despot simpl one uninform bound rmax obtain tighter bound we may exploit domain-specif knowledg here we give domain-independ construct averag upper bound scenario upper bound particular scenario maximum valu achiev arbitrari polici given we determinist plan problem solv dynam program trelli time slice trelli node repres state edg repres action at time step path highest valu trelli give upper bound repeat procedur everi take averag give upper bound valu set comput time initi lower bound default polici construct lower bound at node we may simul polici step scenario comput averag total discount reward time one possibl use fixed-act polici purpos better one handcraft polici choos action base histori action observ techniqu use howev often difficult handcraft effect history-bas polici we thus construct polici use belief mode probabl distribut map specifi action at state s. much intuit construct we approxim easili determin frequent state use note although history-bas polici satisfi requir theorem belief-bas polici differ howev unlik signific affect perform practic experi evalu ab-despot experiment we compar four algorithm anytim basic despot ab-despot ar-despot without dynam program step comput rwdu it help understand benefit regular aems2 earli success onlin pomdp algorithm pomcp scale larg pomdp sarsop state-of-the-art offlin pomdp algorithm it help calibr best perform achiev pomdp moder size our onlin plan test algorithm given exact second per step choos action ar-despot ab-despot regular paramet ar-despot select offlin run algorithm train set distinct onlin test set discount factor pomcp we use implement origin authors3 modifi it order support larg number observ strict follow 1-second time limit onlin plan we evalu algorithm four domain includ larg one state tabl summari compar aems2 ar-despot competit smaller pomdp scale much better larg pomdp compar pomcp ar-despot perform better pomcp smaller pomdp scale well we first test algorithm tag standard benchmark problem tag agent goal find tag target intent move away agent target oper grid possibl posit agent know posit observ target posit locat agent either stay posit move four adjac posit pay cost move it also perform tag action reward it success tag target penal it fail pomcp we use tag implement come packag modifi it slight improv default rollout polici modifi polici alway tag agent posit robot provid better perform ar-despot we use simpl particl set default polici move agent toward mode target particl set upper bound we averag upper bound particl describ section result tabl show ardespot give compar perform aems2 theorem suggest ar-despot may still perform well observ space larg if a good small polici exist examin perform ar-despot larg observ space we experi augment version tag call lasertag lasertag agent move a rectangular grid obstacl place random cell behavior agent oppon ident tag except lasertag agent know it locat game start wherea tag happen first observ seen agent equip a laser give distanc estim direct distanc adjac cell consid one unit laser read direct generat a normal distribut center at true distanc agent nearest obstacl direct a standard deviat unit read discret whole unit observ compris a set integ a map size order environ lasertag shown figur seen tabl ar-despot outperform pomcp this problem we also see figur laser tag agent move a grid obstacl place random effect regular compar ar-despot cell it equip a noisi laser ab-despot it feasibl run aems2 sar give distanc estim direct sop this problem reason time larg observ space demonstr perform ar-despot larg state space we experi rocksampl problem rocksampl n problem mimic a robot move grid contain rock may good bad at step robot either move adjac cell sampl a rock sens a rock sampl give a reward if rock good otherwis both move sampl produc a null observ sens produc observ good bad probabl produc correct observ decreas http //www0.cs.ucl.ac.uk/staff/d.silver/web/applications.html tabl perform comparison accord averag total discount reward achiev result sarsop aems2 replic respect sarsop aems2 fail run domain state space observ space larg for pomcp both result our test parenthes report we could reproduc earlier publish result possibl code modif machin differ tag lasertag no state no action no observ sarsop aems2 pomcp ab-despot ar-despot pocman exponenti agent s distanc rock a termin state reach agent move past east edg map for ar-despot we use a default polici deriv particl set follow a new state creat posit the robot the rock unchang rock label good bad depend whichev condit preval the particl set the optim polici for the result state use the default polici the optim polici for state comput the algorithm begin use dynam program the horizon length the maximum depth the search tree for the initi upper bound we use the method describ section in we use a particl filter to repres the belief to examin the behavior the algorithm in larg state space for pomcp we use the implement in ran it the platform as ar-despot as the result for our run pomcp poorer report in we also reproduc report result in tabl the result in tabl indic ar-despot abl to scale to larg state space regular appear benefici to this problem possibl it most determinist except for the sens action final we implement pocman the partial observ version the video game pacman as describ in pocman extrem larg state space approxim we comput approxim upper bound for a belief sum the follow quantiti for each particl in it take the averag particl reward for eat each pellet discount distanc pocman reward for clear the level discount the maximum distanc to a pellet default per-step reward for a number step equal to the maximum distanc to a pellet penalti for eat a ghost discount the distanc to the closest ghost chase if penalti for die discount the averag distanc to the ghost half the penalti for hit a wall if pocman tri to doubl back along direct movement this need alway upper bound ar-despot modifi to run even this the case for the lower bound we use a history-bas polici chase a random ghost if visibl pocman the effect a powerpil avoid ghost doubling-back when it this exampl show ar-despot use success even in case extrem larg state space conclus this paper present despot a new approach to onlin pomdp plan our r-despot algorithm anytim approxim ar-despot search a despot for approxim optim polici while balanc the size the polici the accuraci valu estim theoret analysi experi show the new approach outperform two the fastest onlin pomdp plan algorithm it scale better aems2 it suffer the extrem poor worst-cas behavior pomcp the perform ar-despot depend the upper lower bound suppli effect method for automat construct bound interest topic for investig acknowledg this work support in part moe acrf grant nation research foundat singapor the smart irg program us air forc research laboratori agreement
----------------------------------------------------------------

title: 4973-aggregating-optimistic-planning-trees-for-solving-markov-decision-processes.pdf

aggreg optimist plan tree solv markov decis process gunnar kedenburg inria lill nord europ idalab gmbh gunnar.kedenburg inria.fr rapha l fonteneau univers li ge inria lill nord europ raphael.fonteneau ulg.ac.b r mi muno inria lill nord europ microsoft research new england remi.muno inria.fr abstract paper address problem onlin plan markov decis process use random simul budget constraint propos new algorithm base construct forest plan tree tree correspond random realize stochast environ tree construct use safe optimist plan strategi combin optimist principl order explor promis part search space first safeti principl guarante certain amount uniform explor decision-mak step algorithm individu tree aggreg immedi action recommend provid finite-sampl analysi discuss trade-off principl optim safeti also report numer result benchmark problem algorithm perform well state-of-the-art optimist plan algorithm better relat algorithm addit assum knowledg transit distribut introduct adapt decis make algorithm use increas past year attract research mani applic area like artifici intellig financi engin medicin robot algorithm realiz adapt control strategi interact environ maxim priori perform criterion new generat algorithm base look-ahead tree search techniqu brought breakthrough practic perform plan problem larg state space techniqu base plan tree mont carlo tree search particular uct algorithm ucb appli tree see allow tackl larg scale problem game go method exploit order decid action given state necessari build estim valu function everywher instead search local space polici around current state propos new algorithm plan markov decis problem mdps assum limit budget call random simul mdp generat model avail explor consequ action make decis intuit behind algorithm achiev high explor depth look-ahead tree plan fix realize mdp achiev necessari explor width aggreg forest plan tree form approxim mdp mani realize tree develop around state decis made accord principl optim face uncertainti combin safeti principl provid finite-sampl analysi depend budget split number tree number node expans tree show algorithm consist identifi optim action given suffici larg budget also give numer result demonstr good perform benchmark problem particular show algorithm achiev much better perform problem op-mdp algorithm generat number successor state despit fact op-mdp assum knowledg successor state probabl mdp wherea algorithm sampl state simul paper organ follow first discuss relat work section section problem address paper formal describ algorithm section finite-sampl analysi given section provid numer result invert pendulum benchmark section section discuss conclud work relat work optim face uncertainti paradigm alreadi lead sever success result solv decis make problem specif appli follow context multi-arm bandit problem seen singl state mdps plan algorithm determinist system stochast system global optim stochast function access sampl see detail review optimist principl appli plan optim algorithm present paper particular close relat two recent develop onlin plan algorithm solv mdps name opd algorithm mdps determinist transit op-mdp algorithm address stochast mdps transit probabl known bayesian adapt op-mdp also propos plan context mdp unknown contribut also relat random ensembl state-act independ disturb scenario built plan problem solv scenario decis made base major vote final sinc algorithm proceed sequenti appli first decis longer plan reced horizon also seen model predict control techniqu formal let markov decis process set respect denot state space finit action space mdp action select state mdp transit successor state s0 probabl assum everi successor state set finit cardin bound n. associ transit determinist instantan reward s0 transit probabl may unknown assum random simul avail given state-act pair output successor state s0 abil sampl weaker assumpt knowledg transit probabl paper consid problem plan budget constraint limit number sampl may drawn use simul afterward singl decis made let denot determinist polici defin valu function polici state discount sum expect reward r st s0 constant call discount factor let optim polici polici maxim state well known optim valu function solut bellman equat max s0 s0 given action-valu function s0 p optim polici deriv argmaxa algorithm name algorithm asop aggreg safe optimist plan main idea behind use simul obtain seri determinist realize stochast mdp plan individu aggreg inform gather determinist mdps empir approxim origin mdp basi decis made refer plan tree use singl successor state tree s3-tree order distinguish plan tree use problem op-mdp tree possibl successor state consid everi node s3-tree repres state one child node per state-act repres successor state s0 s. successor state drawn use simul construct s3-tree plan tree construct use sop algorithm safe optimist plan describ section asop algorithm integr build forest decid action aggreg inform forest describ section safe optimist plan s3-tree sop algorithm sop algorithm sequenti construct s3-tree seen variant opd algorithm plan determinist mdps sop expand two leav plan tree per iter first leaf optimist one maxim upper bound call b-valu valu function determinist realize mdp explor s3-tree b-valu node defin ri ri sequenc reward obtain along path depth node length path root expand optimist leaf would enough make asop consist shown appendix therefor second leaf safe one defin shallowest leaf current tree also expand iter pseudo-cod given algorithm algorithm sop data initi state s0 budget result plan tree let denot tree consist leaf repres s0 initi cost counter while form subset leav contain leaf minim depth leaf maxim b-valu comput accord two leav ident foreach let denot state repres foreach use simul draw successor state s0 creat edg new leaf repres s0 let return aggreg s3-tree asop algorithm asop consist three step first step run independ instanc sop collect inform mdp form forest s3-tree comput action-valu singl empir mdp base collect inform state repres forest transit forest partit group successor state correspond frequenc taken transit probabl leav interpret absorb state zero reward everi action yield trivial lower bound pseudo-cod comput given algorithm asop output action argmax optim polici empir mdp properti empir lower bound valu comput inform collect plan individu realize maxim set polici give pseudo-cod asop algorithm algorithm algorithm actionvalu data forest action tree repres state result empir lower bound valu let denot edg repres action root node return els let set tree point edg e. enumer state repres tree finit i. foreach denot set tree repres si fi let maxa0 actionvalu fi a0 let p fi return i p i s0i algorithm asop data initi state s0 per-tre budget forest size result action take let ti sop s0 return argmaxa actionvalu t1 tm finite-sampl analysi section provid finite-sampl analysi asop term number plan tree per-tre budget immedi consequ analysi asop consist action return asop converg optim action tend infin loss measur simpl regret correspond expect valu first play action return algorithm initi state s0 act optim compar act optim begin rn first let us use safe part sop show s3-tree fulli explor certain depth given suffici larg per-tre budget lemma budget spent sop s3-tree state-act node includ depth sampl exact pd proof complet a|-ari tree contain node level contain node includ level these node action need explor complet proof notic sop spend least half budget shallowest leav let denot valu function polici infinit complet explor s3-tree defin random realize finit s3-tree construct sop budget realize respect lemma deduc per-tre budget least log we obtain ri polici asop aggreg tree comput optim polici result empir mdp whose transit probabl defin frequenc s3-tree transit state-act successor state therefor actual polici maxim function number s3-tree per-tre budget larg we therefor expect optim polici empir mdp close optim polici true mdp result state follow theorem theorem number s3-tree least log log per-tre budget least log rm n proof let fix realize stochast mdp satisfi realize correspond infinit complet explor s3-tree let denot per-tre budget satisfi analog we know lemma given choic sop construct tree complet explor depth fulfil log consid follow truncat valu function let denot sum expect discount reward obtain origin mdp follow polici step receiv reward zero let denot analog quantiti mdp correspond realize pm pm defin polici quantiti v n v i sinc tree complet level reward non-neg we deduc we polici thus true averag v n notic chernoff-hoeffd inequ we fix polici sinc truncat valu lie now we need uniform bound set possibl polici number distinct polici level state reach follow polici previous level differ choic polici make level thus sinc log log we max action return asop argmax v n final it follow probabl least rn v n v n v n definit truncat v n v n truncat remark total budget requir return optim action high probabl log k|a thus order notic rate poorer factor rate obtain uniform plan direct consequ fact we draw sampl wherea full model transit probabl assum remark sinc finit number action denot optim gap best second-best optim action valu we optim arm identifi high log k|a probabl simpl regret total budget order remark optimist part algorithm allow deep explor mdp time it bias express maxim toward near-optim action determinist realize assumpt theorem bias becom insignific remark notic we use optimist properti algorithm analysi analysi use safe part sop plan fact one sampl two devot expand shallowest node analysi benefit optimist part algorithm similar analys carri would much involv defer futur work howev impact optimist part algorithm essenti practic shown numer result numer result section we compar perform asop op-mdp uct fsss we use noisi invert pendulum benchmark problem consist swing stabil weight attach actuat link rotat vertic plane sinc avail power low push pendulum singl rotat initi state pendulum swung back forth gather energi prior push stabil invert pendulum describ state variabl differenti equat mgl k k kg m2 kg nm s/rad nm/a state variabl constrain satur discret time problem obtain map action from segment piecewis control signal durat numer integr differenti equat constant segment use rk4 action appli stochast probabl intend voltag appli control signal wherea probabl smaller voltag appli goal stabil pendulum unstabl equilibrium point rest start from state point rest goal express penalti function s0 a2 s0 reward function obtain scale translat valu penalti function it map interv discount factor set op-mdp uct fsss fsss fsss asop asop sum discount reward call simul per step figur comparison asop op-mdp uct fsss invert pendulum benchmark problem show sum discount reward simul time step algorithm compar sever budget case asop uct fsss budget term call simul op-mdp use simul instead everi possibl successor state incorpor plan tree togeth precis probabl mass these state count budget benchmark problem stochast intern random simul use algorithm except op-mdp perform averag repetit algorithm paramet select manual achiev good perform asop we show result forest size two three uct chernoff-hoeffd term multipli set result sensit valu therefor one result shown fsss we use one three sampl per state-act uct fsss rollout depth seven use op-mdp paramet result shown figur we observ problem asop perform much better op-mdp everi valu budget also perform well comparison sampl base method uct fsss figur show impact optimist plan perform our aggreg method forest size one three optimist plan lead consider increas perform due greater plan depth lookahead tree use optimist explor case singl tree perform decreas presum due overfit stochast problem increas budget effect disappear one tree use conclus we introduc asop novel algorithm solv onlin plan problem use random simul for mdp budget constraint algorithm work construct forest singl successor state tree each correspond random realize mdp transit each tree construct use combin safe optimist plan an empir mdp defin base forest first action optim polici this empir mdp return short our algorithm target structur problem valu function possess smooth properti around optim polici determinist realize mdp a sens defin use optimist principl focus rapid the promis area the search space it also find a reason solut in unstructur problem sinc the budget alloc for uniform explor asop show good perform the invert pendulum benchmark final our algorithm also appeal in the numer heavi part construct the plan tree in the simul use perform in a distribut way sum discount reward safe+optimist safe+optimist safe safe optimist optimist call the simul per step figur comparison differ plan strategi the problem in figur the safe strategi use uniform plan in the individu tree the optimist strategi use opd asop correspond the safe+optimist strategi acknowledg we acknowledg the support the bmbf project alic the european communiti seventh framework programm under grant complac the belgian pai dysco rapha l fonteneau a post-doctor fellow the fnrs we also thank lucian busoniu for share implement op-mdp appendix counterexampl consist use pure optimist plan in s3-tree consid the mdp in figur zero reward transit in the middl branch chosen the tree construct iter everi iter consist explor a leaf maxim b-valu explor a leaf mean introduc a singl successor state per action at the select leaf the state-act valu there two possibl outcom when sampl the action a occur probabl respect outcom i the upper branch action a sampl in this case the contribut the forest an arbitrarili long reward path for action a a finit reward path for action outcom the lower branch action a sampl becaus the lower branch explor time as it b-valu lower the valu therefor b-valu action the contribut this case the forest a finit reward path for action a an arbitrari long depend the budget reward path for action for an increas explor budget per tree an increas number tree the approxim action valu action a obtain aggreg converg respect therefor the decis rule select action for a suffici larg budget even though a the optim action this lead simpl regret s0 a figur the middl branch this mdp never explor deep enough if onli the node the largest b-valu sampl in each iter transit probabl given in gray equal one
----------------------------------------------------------------

